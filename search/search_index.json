{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stemmer","stopWordFilter"]},"docs":[{"location":"","title":"FastAPI Cachekit","text":"<p>FastAPI Cachekit is a high-performance, pluggable caching extension for FastAPI. It provides a unified, developer-friendly interface for adding caching to your FastAPI applications, supporting multiple backends and both synchronous and asynchronous APIs.</p>"},{"location":"#what-is-fastapi-cachekit","title":"\ud83d\ude80 What is FastAPI Cachekit?","text":"<p>FastAPI Cachekit is a library designed to make caching in FastAPI apps easy, flexible, and production-ready. It allows you to cache expensive computations, database queries, or API responses using a simple decorator or dependency injection, with support for:</p> <ul> <li>In-memory caching (for local development and testing)</li> <li>Redis (for distributed, production-grade caching)</li> <li>PostgreSQL (for persistent, SQL-based caching)</li> <li>Memcached (for high-speed, distributed caching)</li> </ul> <p>You can choose the backend that fits your needs, and switch between them with minimal code changes.</p>"},{"location":"#benefits","title":"\ud83c\udf1f Benefits","text":"<ul> <li>Plug-and-play: Add caching to any FastAPI endpoint with a simple decorator.</li> <li>Multiple backends: Use in-memory, Redis, Postgres, or Memcache etc. Swap backends with a single line of code.</li> <li>Sync &amp; Async support: Works seamlessly with both synchronous and asynchronous FastAPI endpoints.</li> <li>Performance: Reduce database load, speed up API responses, and improve scalability.</li> <li>Optional dependencies: Only install the backend you need, keeping your project lightweight.</li> <li>Production-ready: Tested with Docker, testcontainers, and CI for reliability.</li> <li>Easy integration: Works with FastAPI\u2019s dependency injection and lifespan events.</li> </ul>"},{"location":"#backends-syncasync-support","title":"\ud83d\udce6 Backends &amp; Sync/Async Support","text":"Backend Sync API Async API Install Extra Setup Guide <code>InMemoryBackend</code> \u2705 \u2705 built-in Guide <code>RedisBackend</code> \u2705 \u2705 <code>redis</code> Guide <code>PostgresBackend</code> \u2705 \u2705 <code>postgres</code> Guide <code>MemcachedBackend</code> \u2705 \u2705 <code>memcached</code> Guide <code>MongoDBBackend</code> \u2705 \u2705 <code>mongodb</code> Guide <code>FirestoreBackend</code> \u2705 \u2705 <code>firestore</code> Guide <code>DynamoDBBackend</code> \u2705 \u2705 <code>dynamodb</code> Guide --- ## \ud83e\uddd1\u200d\ud83d\udcbb Example Usage"},{"location":"#1-decorator-based-caching","title":"1. Decorator-Based Caching","text":"<p>Cache the result of a function or endpoint automatically using the <code>@cache.cached</code> decorator:</p> <pre><code>from fast_cache import cache, InMemoryBackend\n\nbackend = InMemoryBackend()\ncache.init_app(app, backend)\n\n@app.get(\"/expensive\")\n@cache.cached(expire=60)\nasync def expensive_operation(x: int):\n    # Simulate expensive work\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"#2-dependency-injection-direct-backend-access","title":"2. Dependency Injection: Direct Backend Access","text":"<p>You can inject the cache backend into your endpoint for full control:</p> <pre><code>from fastapi import Depends\nfrom typing import Annotated\n\n@app.get(\"/expensive-direct\")\nasync def expensive_operation_direct(\n    x: int,\n    cache_backend: Annotated[InMemoryBackend, Depends(cache.get_cache)],\n):\n    cache_key = f\"expensive:{x}\"\n    # Try to get from cache\n    cached = await cache_backend.aget(cache_key)\n    if cached is not None:\n        return {\"result\": cached, \"cached\": True}\n    # Simulate expensive work\n    result = x * 2\n    await cache_backend.aset(cache_key, result, expire=60)\n    return {\"result\": result, \"cached\": False}\n</code></pre>"},{"location":"#3-sync-function-caching-decorator","title":"3. Sync Function Caching (Decorator)","text":"<p>You can also cache sync functions:</p> <pre><code>@app.get(\"/expensive-sync\")\n@cache.cached(expire=60)\ndef expensive_operation_sync(x: int):\n    # Simulate expensive work\n    return {\"result\": x * 3}\n</code></pre> <p>Tip: - Use the decorator for simple, automatic caching. - Use dependency injection for advanced or custom cache logic.</p> <p>FastAPI Cachekit makes caching in FastAPI simple, powerful, and flexible so you can focus on building fast, reliable APIs.</p> <p>Next: Installation \u2192</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#main-cache-interface","title":"Main Cache Interface","text":""},{"location":"api/#fast_cache.FastAPICache","title":"fast_cache.FastAPICache","text":"<pre><code>FastAPICache()\n</code></pre> <p>FastAPI Cache Extension.</p> <p>This class provides caching utilities for FastAPI applications, including decorator-based caching and dependency-injection-based backend access.</p> <p>Initialize the FastAPICache instance.</p> Source code in <code>fast_cache/integration.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the FastAPICache instance.\n    \"\"\"\n    self._backend: Optional[CacheBackend] = None\n    self._app: Optional[FastAPI] = None\n    self._default_expire: Optional[Union[int, timedelta]] = None\n</code></pre>"},{"location":"api/#fast_cache.FastAPICache.get_cache","title":"get_cache","text":"<pre><code>get_cache()\n</code></pre> <p>Get the configured cache backend for dependency injection.</p> <p>Returns:</p> Name Type Description <code>CacheBackend</code> <code>CacheBackend</code> <p>The configured cache backend instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the cache is not initialized.</p> Source code in <code>fast_cache/integration.py</code> <pre><code>def get_cache(self) -&gt; CacheBackend:\n    \"\"\"\n    Get the configured cache backend for dependency injection.\n\n    Returns:\n        CacheBackend: The configured cache backend instance.\n\n    Raises:\n        RuntimeError: If the cache is not initialized.\n    \"\"\"\n    if self._backend is None:\n        raise RuntimeError(\"Cache not initialized. Call init_app first.\")\n    return self._backend\n</code></pre>"},{"location":"api/#fast_cache.FastAPICache.cached","title":"cached","text":"<pre><code>cached(expire=None, key_builder=None, namespace=None)\n</code></pre> <p>Decorator for caching function results.</p> <p>Parameters:</p> Name Type Description Default <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as a timedelta.</p> <code>None</code> <code>key_builder</code> <code>Optional[Callable[..., str]]</code> <p>Custom function to build the cache key.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>Optional namespace for the cache key.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable[[Callable[..., Any]], Callable[..., Any]]</code> <p>A decorator that caches the function result.</p> Source code in <code>fast_cache/integration.py</code> <pre><code>def cached(\n    self,\n    expire: Optional[Union[int, timedelta]] = None,\n    key_builder: Optional[Callable[..., str]] = None,\n    namespace: Optional[str] = None,\n) -&gt; Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"\n    Decorator for caching function results.\n\n    Args:\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as a timedelta.\n        key_builder (Optional[Callable[..., str]]): Custom function to build the cache key.\n        namespace (Optional[str]): Optional namespace for the cache key.\n\n    Returns:\n        Callable: A decorator that caches the function result.\n    \"\"\"\n\n    def decorator(func: Callable) -&gt; Callable[..., Any]:\n        \"\"\"\n        The actual decorator that wraps the function.\n\n        Args:\n            func (Callable): The function to be cached.\n\n        Returns:\n            Callable: The wrapped function with caching.\n        \"\"\"\n        is_async = inspect.iscoroutinefunction(func)\n\n        def build_cache_key(*args, **kwargs) -&gt; str:\n            \"\"\"\n            Build the cache key for the function call.\n\n            Args:\n                *args: Positional arguments for the function.\n                **kwargs: Keyword arguments for the function.\n\n            Returns:\n                str: The generated cache key.\n            \"\"\"\n            if key_builder is not None:\n                key = key_builder(*args, **kwargs)\n            else:\n                # Default key building logic\n                key = f\"{func.__module__}:{func.__name__}:{str(args)}:{str(kwargs)}\"\n\n            if namespace:\n                key = f\"{namespace}:{key}\"\n\n            return key\n\n        @wraps(func)\n        async def async_wrapper(*args, **kwargs) -&gt; Any:\n            \"\"\"\n            Async wrapper for caching.\n\n            Args:\n                *args: Positional arguments.\n                **kwargs: Keyword arguments.\n\n            Returns:\n                Any: The cached or computed result.\n            \"\"\"\n            if not self._backend:\n                return await func(*args, **kwargs)\n\n            # Skip cache if explicitly requested\n            if kwargs.pop(\"skip_cache\", False):\n                return await func(*args, **kwargs)\n\n            cache_key = build_cache_key(*args, **kwargs)\n\n            # Try to get from cache\n            cached_value = await self._backend.aget(cache_key)\n            if cached_value is not None:\n                return cached_value\n\n            # Execute function and cache result\n            result = await func(*args, **kwargs)\n            await self._backend.aset(\n                cache_key, result, expire=expire or self._default_expire\n            )\n            return result\n\n        @wraps(func)\n        def sync_wrapper(*args, **kwargs):\n            \"\"\"\n            Sync wrapper for caching.\n\n            Args:\n                *args: Positional arguments.\n                **kwargs: Keyword arguments.\n\n            Returns:\n                Any: The cached or computed result.\n            \"\"\"\n            if not self._backend:\n                return func(*args, **kwargs)\n\n            # Skip cache if explicitly requested\n            if kwargs.pop(\"skip_cache\", False):\n                return func(*args, **kwargs)\n\n            cache_key = build_cache_key(*args, **kwargs)\n\n            # Try to get from cache\n            cached_value = self._backend.get(cache_key)\n            if cached_value is not None:\n                return cached_value\n\n            # Execute function and cache result\n            result = func(*args, **kwargs)\n            self._backend.set(\n                cache_key, result, expire=expire or self._default_expire\n            )\n            return result\n\n        return async_wrapper if is_async else sync_wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/#fast_cache.FastAPICache.lifespan_handler","title":"lifespan_handler  <code>async</code>","text":"<pre><code>lifespan_handler(app)\n</code></pre> <p>Lifespan context manager for FastAPI.</p> <p>This can be used as the <code>lifespan</code> argument to FastAPI to manage cache lifecycle.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>The FastAPI application instance.</p> required <p>Yields:</p> Type Description <code>AsyncIterator[None]</code> <p>None</p> Source code in <code>fast_cache/integration.py</code> <pre><code>@asynccontextmanager\nasync def lifespan_handler(self, app: FastAPI) -&gt; AsyncIterator[None]:\n    \"\"\"\n    Lifespan context manager for FastAPI.\n\n    This can be used as the `lifespan` argument to FastAPI to manage\n    cache lifecycle.\n\n    Args:\n        app (FastAPI): The FastAPI application instance.\n\n    Yields:\n        None\n    \"\"\"\n    if not hasattr(app, \"state\"):\n        app.state = {}\n    app.state[\"cache\"] = self\n\n    try:\n        yield\n    finally:\n        if self._backend:\n            close = getattr(self._backend, \"aclose\", None)\n            if close:\n                await close()\n            else:\n                close = getattr(self._backend, \"close\", None)\n                if close:\n                    close()\n\n        self._backend = None\n        self._app = None\n</code></pre>"},{"location":"api/#fast_cache.FastAPICache.init_app","title":"init_app","text":"<pre><code>init_app(app, backend, default_expire=None)\n</code></pre> <p>Initialize the cache extension.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>FastAPI</code> <p>FastAPI application instance.</p> required <code>backend</code> <code>CacheBackend</code> <p>Cache backend instance.</p> required <code>default_expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Default expiration time for cached items.</p> <code>None</code> Source code in <code>fast_cache/integration.py</code> <pre><code>def init_app(\n    self,\n    app: FastAPI,\n    backend: CacheBackend,\n    default_expire: Optional[Union[int, timedelta]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the cache extension.\n\n    Args:\n        app (FastAPI): FastAPI application instance.\n        backend (CacheBackend): Cache backend instance.\n        default_expire (Optional[Union[int, timedelta]]): Default expiration time for cached items.\n    \"\"\"\n    self._backend = backend\n    self._app = app\n    self._default_expire = default_expire\n</code></pre>"},{"location":"api/#backends","title":"Backends","text":""},{"location":"api/#fast_cache.InMemoryBackend","title":"fast_cache.InMemoryBackend","text":"<pre><code>InMemoryBackend(namespace='fastapi-cache', max_size=None, cleanup_interval=30)\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>Initializes a new instance of the InMemoryBackend cache.</p> <p>This backend provides an in-memory cache with optional LRU (Least Recently Used) eviction, namespace support, thread and async safety, and automatic periodic cleanup of expired items. It is suitable for single-process, multi-threaded, or asyncio-based applications.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>A namespace prefix for all cache keys. This allows multiple independent caches to share the same process. Defaults to \"fastapi-cache\".</p> <code>'fastapi-cache'</code> <code>max_size</code> <code>Optional[int]</code> <p>The maximum number of items to store in the cache. If set, the cache will evict the least recently used items when the limit is exceeded. If None, the cache size is unlimited. Defaults to None.</p> <code>None</code> <code>cleanup_interval</code> <code>int</code> <p>The interval, in seconds, at which the background cleanup job runs to remove expired cache entries. Defaults to 30.</p> <code>30</code> Notes <ul> <li>The backend uses an OrderedDict to maintain LRU order.</li> <li>Both synchronous (thread-safe) and asynchronous (asyncio-safe) operations are supported.</li> <li>Expired items are removed automatically by a background scheduler.</li> <li>This backend is not suitable for multi-process or distributed environments.</li> </ul> <p>Initialize the in-memory cache backend.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Namespace prefix for all keys.</p> <code>'fastapi-cache'</code> <code>max_size</code> <code>Optional[int]</code> <p>Optional maximum number of items (LRU eviction if set).</p> <code>None</code> <code>cleanup_interval</code> <code>int</code> <p>Interval in seconds for background cleanup.</p> <code>30</code> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def __init__(\n    self,\n    namespace: str = \"fastapi-cache\",\n    max_size: Optional[int] = None,\n    cleanup_interval: int = 30,\n) -&gt; None:\n    \"\"\"\n    Initialize the in-memory cache backend.\n\n    Args:\n        namespace: Namespace prefix for all keys.\n        max_size: Optional maximum number of items (LRU eviction if set).\n        cleanup_interval: Interval in seconds for background cleanup.\n    \"\"\"\n    self._namespace = namespace\n    self._cache: OrderedDict[str, Tuple[Any, Optional[float]]] = OrderedDict()\n    self._lock = threading.Lock()\n    self._async_lock = asyncio.Lock()\n    self._max_size = max_size\n    self._cleanup_interval = cleanup_interval\n\n    self._scheduler = None\n    self._scheduler_lock = threading.Lock()\n    self._start_cleanup_scheduler()\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieves a value from the cache by key.</p> <p>If the key does not exist or the entry has expired, returns None. If the entry is expired, it is deleted from the cache (lazy deletion). Accessing an item moves it to the end of the LRU order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found or expired.</p> Notes <ul> <li>Thread-safe.</li> <li>Expired entries are removed on access.</li> <li>Updates LRU order on access.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieves a value from the cache by key.\n\n    If the key does not exist or the entry has expired, returns None. If the\n    entry is expired, it is deleted from the cache (lazy deletion). Accessing\n    an item moves it to the end of the LRU order.\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found or expired.\n\n    Notes:\n        - Thread-safe.\n        - Expired entries are removed on access.\n        - Updates LRU order on access.\n    \"\"\"\n    k = self._make_key(key)\n    with self._lock:\n        item = self._cache.get(k)\n        if item:\n            value, expire_time = item\n            if not self._is_expired(expire_time):\n                self._cache.move_to_end(k)\n                return value\n            self._cache.pop(k, None)\n        return None\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion. Setting an item moves it to the end of the LRU order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>Thread-safe.</li> <li>Triggers LRU eviction if max_size is set.</li> <li>Updates LRU order on set.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion. Setting an item moves it to\n    the end of the LRU order.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object to cache.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - Thread-safe.\n        - Triggers LRU eviction if max_size is set.\n        - Updates LRU order on set.\n    \"\"\"\n    k = self._make_key(key)\n    expire_time = self._get_expire_time(expire)\n    with self._lock:\n        self._cache[k] = (value, expire_time)\n        self._cache.move_to_end(k)\n        self._evict_if_needed()\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Thread-safe.</li> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Thread-safe.\n        - The key is automatically namespaced.\n    \"\"\"\n    k = self._make_key(key)\n    with self._lock:\n        self._cache.pop(k, None)\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Synchronously removes all cache entries in the current namespace.</p> <p>This method deletes all entries whose keys match the current namespace prefix.</p> Notes <ul> <li>Thread-safe.</li> <li>Only entries in the current namespace are affected.</li> <li>This operation can be expensive if the cache is large.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Synchronously removes all cache entries in the current namespace.\n\n    This method deletes all entries whose keys match the current namespace prefix.\n\n    Notes:\n        - Thread-safe.\n        - Only entries in the current namespace are affected.\n        - This operation can be expensive if the cache is large.\n    \"\"\"\n    prefix = f\"{self._namespace}:\"\n    with self._lock:\n        keys_to_delete = [k for k in self._cache if k.startswith(prefix)]\n        for k in keys_to_delete:\n            self._cache.pop(k, None)\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously checks if a cache key exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Notes <ul> <li>Thread-safe.</li> <li>Expired entries are not considered present and are removed on check.</li> <li>Updates LRU order on access.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously checks if a cache key exists and is not expired.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n\n    Notes:\n        - Thread-safe.\n        - Expired entries are not considered present and are removed on check.\n        - Updates LRU order on access.\n    \"\"\"\n    k = self._make_key(key)\n    with self._lock:\n        item = self._cache.get(k)\n        if item:\n            _, expire_time = item\n            if not self._is_expired(expire_time):\n                self._cache.move_to_end(k)\n                return True\n            self._cache.pop(k, None)\n        return False\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieves a value from the cache by key.</p> <p>If the key does not exist or the entry has expired, returns None. If the entry is expired, it is deleted from the cache (lazy deletion). Accessing an item moves it to the end of the LRU order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found or expired.</p> Notes <ul> <li>Asyncio-safe.</li> <li>Expired entries are removed on access.</li> <li>Updates LRU order on access.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieves a value from the cache by key.\n\n    If the key does not exist or the entry has expired, returns None. If the\n    entry is expired, it is deleted from the cache (lazy deletion). Accessing\n    an item moves it to the end of the LRU order.\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found or expired.\n\n    Notes:\n        - Asyncio-safe.\n        - Expired entries are removed on access.\n        - Updates LRU order on access.\n    \"\"\"\n    k = self._make_key(key)\n    async with self._async_lock:\n        item = self._cache.get(k)\n        if item:\n            value, expire_time = item\n            if not self._is_expired(expire_time):\n                self._cache.move_to_end(k)\n                return value\n            self._cache.pop(k, None)\n        return None\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion. Setting an item moves it to the end of the LRU order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>Asyncio-safe.</li> <li>Triggers LRU eviction if max_size is set.</li> <li>Updates LRU order on set.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion. Setting an item moves it to\n    the end of the LRU order.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object to cache.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - Asyncio-safe.\n        - Triggers LRU eviction if max_size is set.\n        - Updates LRU order on set.\n    \"\"\"\n    k = self._make_key(key)\n    expire_time = self._get_expire_time(expire)\n    async with self._async_lock:\n        self._cache[k] = (value, expire_time)\n        self._cache.move_to_end(k)\n        self._evict_if_needed()\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Asyncio-safe.</li> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Asyncio-safe.\n        - The key is automatically namespaced.\n    \"\"\"\n    k = self._make_key(key)\n    async with self._async_lock:\n        self._cache.pop(k, None)\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously removes all cache entries in the current namespace.</p> <p>This method deletes all entries whose keys match the current namespace prefix.</p> Notes <ul> <li>Asyncio-safe.</li> <li>Only entries in the current namespace are affected.</li> <li>This operation can be expensive if the cache is large.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously removes all cache entries in the current namespace.\n\n    This method deletes all entries whose keys match the current namespace prefix.\n\n    Notes:\n        - Asyncio-safe.\n        - Only entries in the current namespace are affected.\n        - This operation can be expensive if the cache is large.\n    \"\"\"\n    prefix = f\"{self._namespace}:\"\n    async with self._async_lock:\n        keys_to_delete = [k for k in self._cache if k.startswith(prefix)]\n        for k in keys_to_delete:\n            self._cache.pop(k, None)\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously checks if a cache key exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Notes <ul> <li>Asyncio-safe.</li> <li>Expired entries are not considered present and are removed on check.</li> <li>Updates LRU order on access.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously checks if a cache key exists and is not expired.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n\n    Notes:\n        - Asyncio-safe.\n        - Expired entries are not considered present and are removed on check.\n        - Updates LRU order on access.\n    \"\"\"\n    k = self._make_key(key)\n    async with self._async_lock:\n        item = self._cache.get(k)\n        if item:\n            _, expire_time = item\n            if not self._is_expired(expire_time):\n                self._cache.move_to_end(k)\n                return True\n            self._cache.pop(k, None)\n        return False\n</code></pre>"},{"location":"api/#fast_cache.InMemoryBackend.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the backend and stops the background cleanup scheduler.</p> <p>This method should be called when the backend is no longer needed to ensure all resources are released and background jobs are stopped.</p> Notes <ul> <li>After calling this method, the cache is cleared and cannot be used.</li> <li>The background cleanup scheduler is stopped.</li> </ul> Source code in <code>fast_cache/backends/memory.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Closes the backend and stops the background cleanup scheduler.\n\n    This method should be called when the backend is no longer needed to ensure\n    all resources are released and background jobs are stopped.\n\n    Notes:\n        - After calling this method, the cache is cleared and cannot be used.\n        - The background cleanup scheduler is stopped.\n    \"\"\"\n    self._stop_cleanup_scheduler()\n    self._cache = None\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend","title":"fast_cache.RedisBackend","text":"<pre><code>RedisBackend(redis_url, namespace='fastapi-cache', pool_size=10, max_connections=20)\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>Redis cache backend implementation with namespace support.</p> <p>Attributes:</p> Name Type Description <code>_namespace</code> <code>str</code> <p>Namespace prefix for all keys.</p> <code>_sync_pool</code> <code>ConnectionPool</code> <p>Synchronous Redis connection pool.</p> <code>_async_pool</code> <code>ConnectionPool</code> <p>Asynchronous Redis connection pool.</p> <code>_sync_client</code> <code>Redis</code> <p>Synchronous Redis client.</p> <code>_async_client</code> <code>Redis</code> <p>Asynchronous Redis client.</p> <p>Initialize Redis backend with connection URL and pool settings.</p> <p>Parameters:</p> Name Type Description Default <code>redis_url</code> <code>str</code> <p>Redis connection URL (e.g., \"redis://localhost:6379/0\").</p> required <code>namespace</code> <code>str</code> <p>Namespace prefix for all keys (default: \"fastapi-cache\").</p> <code>'fastapi-cache'</code> <code>pool_size</code> <code>int</code> <p>Minimum number of connections in the pool.</p> <code>10</code> <code>max_connections</code> <code>int</code> <p>Maximum number of connections in the pool.</p> <code>20</code> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>def __init__(\n    self,\n    redis_url: str,\n    namespace: str = \"fastapi-cache\",\n    pool_size: int = 10,\n    max_connections: int = 20,\n) -&gt; None:\n    \"\"\"\n    Initialize Redis backend with connection URL and pool settings.\n\n    Args:\n        redis_url (str): Redis connection URL (e.g., \"redis://localhost:6379/0\").\n        namespace (str): Namespace prefix for all keys (default: \"fastapi-cache\").\n        pool_size (int): Minimum number of connections in the pool.\n        max_connections (int): Maximum number of connections in the pool.\n    \"\"\"\n\n    try:\n        import redis.asyncio as aioredis\n        import redis\n    except ImportError:\n        raise ImportError(\n            \"RedisBackend requires the 'redis' package. \"\n            \"Install it with: pip install fast-cache[redis]\"\n        )\n\n    self._namespace = namespace\n    self._sync_pool = redis.ConnectionPool.from_url(\n        redis_url, max_connections=max_connections, decode_responses=False\n    )\n\n    self._async_pool = aioredis.ConnectionPool.from_url(\n        redis_url,\n        max_connections=max_connections,\n        decode_responses=False,\n        encoding=\"utf-8\",\n    )\n\n    self._sync_client = redis.Redis(connection_pool=self._sync_pool)\n    self._async_client = aioredis.Redis(connection_pool=self._async_pool)\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found.\n    \"\"\"\n    try:\n        result = await self._async_client.get(self._make_key(key))\n        return pickle.loads(result) if result else None\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found.\n    \"\"\"\n    try:\n        result = self._sync_client.get(self._make_key(key))\n        return pickle.loads(result) if result else None\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>Any</code> <p>The value to store.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.</p> <code>None</code> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously set a value in the cache.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (Any): The value to store.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n    \"\"\"\n    try:\n        ex = expire.total_seconds() if isinstance(expire, timedelta) else expire\n        await self._async_client.set(\n            self._make_key(key), pickle.dumps(value), ex=ex\n        )\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>Any</code> <p>The value to store.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.</p> <code>None</code> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously set a value in the cache.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (Any): The value to store.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n    \"\"\"\n    try:\n        ex = expire.total_seconds() if isinstance(expire, timedelta) else expire\n        self._sync_client.set(self._make_key(key), pickle.dumps(value), ex=ex)\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required Source code in <code>fast_cache/backends/redis.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously delete a value from the cache.\n\n    Args:\n        key (str): The key to delete.\n    \"\"\"\n    try:\n        await self._async_client.delete(self._make_key(key))\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required Source code in <code>fast_cache/backends/redis.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously delete a value from the cache.\n\n    Args:\n        key (str): The key to delete.\n    \"\"\"\n    try:\n        self._sync_client.delete(self._make_key(key))\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously clear all values from the namespace.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously clear all values from the namespace.\n    \"\"\"\n    try:\n        keys = await self._scan_keys()\n        if keys:\n            await self._async_client.delete(*keys)\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Synchronously clear all values from the namespace.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Synchronously clear all values from the namespace.\n    \"\"\"\n    try:\n        cursor = 0\n        namespace_pattern = self._make_key(\"*\")\n\n        while True:\n            cursor, keys = self._sync_client.scan(\n                cursor=cursor, match=namespace_pattern, count=100\n            )\n            if keys:\n                self._sync_client.delete(*keys)\n            if cursor == 0:\n                break\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    try:\n        return await self._async_client.exists(self._make_key(key)) &gt; 0\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    try:\n        return self._sync_client.exists(self._make_key(key)) &gt; 0\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#fast_cache.RedisBackend.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close Redis connections and clean up pools.</p> Source code in <code>fast_cache/backends/redis.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Close Redis connections and clean up pools.\n    \"\"\"\n    await self._async_client.close()\n    await self._async_pool.disconnect()\n    self._sync_client.close()\n    self._sync_pool.disconnect()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend","title":"fast_cache.PostgresBackend","text":"<pre><code>PostgresBackend(dsn, namespace='fastapi', min_size=1, max_size=10, cleanup_interval=30, auto_cleanup=True)\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>PostgreSQL cache backend implementation.</p> <p>Uses an UNLOGGED TABLE for performance and lazy expiration.</p> <p>Initializes a new instance of the PostgresBackend cache.</p> <p>This backend uses a PostgreSQL database to store cache entries in an UNLOGGED TABLE for improved performance. It supports both synchronous and asynchronous operations, lazy expiration, and periodic cleanup of expired entries.</p> <p>Parameters:</p> Name Type Description Default <code>dsn</code> <code>str</code> <p>The PostgreSQL DSN (Data Source Name) string used to connect to the database.</p> required <code>namespace</code> <code>str</code> <p>A namespace prefix for all cache keys. This allows multiple independent caches to share the same database table. Only alphanumeric characters and underscores are allowed. Defaults to \"fastapi\".</p> <code>'fastapi'</code> <code>min_size</code> <code>int</code> <p>The minimum number of connections to maintain in the connection pool. Defaults to 1.</p> <code>1</code> <code>max_size</code> <code>int</code> <p>The maximum number of connections allowed in the connection pool. Defaults to 10.</p> <code>10</code> <code>cleanup_interval</code> <code>int</code> <p>The interval, in seconds, at which the background cleanup job runs to remove expired cache entries. Defaults to 30 seconds.</p> <code>30</code> <code>auto_cleanup</code> <code>bool</code> <p>If True, automatically starts the background cleanup scheduler on initialization. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the required <code>psycopg[pool]</code> package is not installed.</p> <code>ValueError</code> <p>If the provided namespace contains invalid characters.</p> Notes <ul> <li>The backend creates the cache table and an index on the expiration   column if they do not already exist.</li> <li>The cleanup scheduler can be started or stopped manually.</li> <li>Both synchronous and asynchronous connection pools are managed.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def __init__(\n    self,\n    dsn: str,\n    namespace: str = \"fastapi\",\n    min_size: int = 1,\n    max_size: int = 10,\n    cleanup_interval: int = 30,\n    auto_cleanup: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the PostgresBackend cache.\n\n    This backend uses a PostgreSQL database to store cache entries in an\n    UNLOGGED TABLE for improved performance. It supports both synchronous and\n    asynchronous operations, lazy expiration, and periodic cleanup of expired\n    entries.\n\n    Args:\n        dsn (str): The PostgreSQL DSN (Data Source Name) string used to connect\n            to the database.\n        namespace (str, optional): A namespace prefix for all cache keys. This\n            allows multiple independent caches to share the same database table.\n            Only alphanumeric characters and underscores are allowed. Defaults to \"fastapi\".\n        min_size (int, optional): The minimum number of connections to maintain\n            in the connection pool. Defaults to 1.\n        max_size (int, optional): The maximum number of connections allowed in\n            the connection pool. Defaults to 10.\n        cleanup_interval (int, optional): The interval, in seconds, at which the\n            background cleanup job runs to remove expired cache entries.\n            Defaults to 30 seconds.\n        auto_cleanup (bool, optional): If True, automatically starts the\n            background cleanup scheduler on initialization. Defaults to True.\n\n    Raises:\n        ImportError: If the required `psycopg[pool]` package is not installed.\n        ValueError: If the provided namespace contains invalid characters.\n\n    Notes:\n        - The backend creates the cache table and an index on the expiration\n          column if they do not already exist.\n        - The cleanup scheduler can be started or stopped manually.\n        - Both synchronous and asynchronous connection pools are managed.\n    \"\"\"\n    try:\n        from psycopg_pool import AsyncConnectionPool, ConnectionPool\n    except ImportError:\n        raise ImportError(\n            \"PostgresBackend requires the 'psycopg[pool]' package. \"\n            \"Install it with: pip install fast-cache[postgres]\"\n        )\n\n    self._namespace = _validate_namespace(namespace)\n    self._table_name = f\"{namespace}_cache_store\"\n\n    # The pools are opened on creation and will auto-reopen if needed\n    # when using the context manager (`with/async with`).\n    self._sync_pool = ConnectionPool(\n        conninfo=dsn, min_size=min_size, max_size=max_size, open=True\n    )\n    self._async_pool = AsyncConnectionPool(\n        conninfo=dsn, min_size=min_size, max_size=max_size, open=False\n    )\n    self._create_unlogged_table_if_not_exists()\n\n    self._cleanup_interval = cleanup_interval\n    self._auto_cleanup = auto_cleanup\n\n    self._scheduler = None\n    self._scheduler_lock = threading.Lock()\n\n    if self._auto_cleanup:\n        self._start_cleanup_scheduler()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object/values to cache. It will be serialized using pickle.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>The key is automatically namespaced.</li> <li>Expired entries are lazily deleted on access or by the cleanup job.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object/values to cache. It will be serialized using pickle.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - The key is automatically namespaced.\n        - Expired entries are lazily deleted on access or by the cleanup job.\n    \"\"\"\n    expire_at = self._compute_expire_at(expire)\n    with self._sync_pool.connection() as conn:\n        with conn.cursor() as cur:\n            cur.execute(\n                f\"\"\"\n                INSERT INTO {self._table_name} (key, value, expire_at)\n                VALUES (%s, %s, %s)\n                ON CONFLICT (key)\n                DO UPDATE SET value = EXCLUDED.value,\n                              expire_at = EXCLUDED.expire_at;\n                \"\"\",\n                (self._make_key(key), pickle.dumps(value), expire_at),\n            )\n            conn.commit()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Retrieves a value from the cache by key.</p> <p>If the key does not exist or the entry has expired, returns None. If the entry is expired, it is deleted from the cache (lazy deletion).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found or expired.</p> Notes <ul> <li>The value is deserialized using pickle.</li> <li>Expired entries are removed on access.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Retrieves a value from the cache by key.\n\n    If the key does not exist or the entry has expired, returns None. If the\n    entry is expired, it is deleted from the cache (lazy deletion).\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found or expired.\n\n    Notes:\n        - The value is deserialized using pickle.\n        - Expired entries are removed on access.\n    \"\"\"\n    with self._sync_pool.connection() as conn:\n        with conn.cursor() as cur:\n            cur.execute(\n                f\"SELECT value, expire_at FROM {self._table_name} WHERE key = %s;\",\n                (self._make_key(key),),\n            )\n            row = cur.fetchone()\n            if not row:\n                return None\n            value, expire_at = row\n            if self._is_expired(expire_at):\n                self.delete(key)  # Lazy delete\n                return None\n            return pickle.loads(value)\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - The key is automatically namespaced.\n    \"\"\"\n    with self._sync_pool.connection() as conn:\n        with conn.cursor() as cur:\n            cur.execute(\n                f\"DELETE FROM {self._table_name} WHERE key = %s;\",\n                (self._make_key(key),),\n            )\n            conn.commit()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Checks if a cache key exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Notes <ul> <li>Expired entries are not considered present.</li> <li>Does not remove expired entries; use <code>get</code> for lazy deletion.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Checks if a cache key exists and is not expired.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n\n    Notes:\n        - Expired entries are not considered present.\n        - Does not remove expired entries; use `get` for lazy deletion.\n    \"\"\"\n    with self._sync_pool.connection() as conn:\n        with conn.cursor() as cur:\n            cur.execute(\n                f\"SELECT expire_at FROM {self._table_name} WHERE key = %s;\",\n                (self._make_key(key),),\n            )\n            row = cur.fetchone()\n            if not row:\n                return False\n            return not self._is_expired(row[0])\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Removes all cache entries in the current namespace.</p> <p>This method deletes all rows from the cache table whose keys match the current namespace prefix.</p> Notes <ul> <li>Only entries in the current namespace are affected.</li> <li>This operation can be expensive if the cache is large.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Removes all cache entries in the current namespace.\n\n    This method deletes all rows from the cache table whose keys match the\n    current namespace prefix.\n\n    Notes:\n        - Only entries in the current namespace are affected.\n        - This operation can be expensive if the cache is large.\n    \"\"\"\n\n    with self._sync_pool.connection() as conn:\n        with conn.cursor() as cur:\n            # FIX: Use the dynamic table name\n            cur.execute(\n                f\"DELETE FROM {self._table_name} WHERE key LIKE %s;\",\n                (self._make_key(\"%\"),),\n            )\n            conn.commit()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object/values to cache. It will be serialized using pickle.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>Uses the asynchronous connection pool.</li> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object/values to cache. It will be serialized using pickle.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - Uses the asynchronous connection pool.\n        - The key is automatically namespaced.\n    \"\"\"\n    await self._ensure_async_pool_open()\n    expire_at = self._compute_expire_at(expire)\n    async with self._async_pool.connection() as conn:\n        async with conn.cursor() as cur:\n            await cur.execute(\n                f\"\"\"\n                INSERT INTO {self._table_name} (key, value, expire_at)\n                VALUES (%s, %s, %s)\n                ON CONFLICT (key)\n                DO UPDATE SET value = EXCLUDED.value,\n                              expire_at = EXCLUDED.expire_at;\n                \"\"\",\n                (self._make_key(key), pickle.dumps(value), expire_at),\n            )\n            await conn.commit()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieves a value from the cache by key.</p> <p>If the key does not exist or the entry has expired, returns None. If the entry is expired, it is deleted from the cache (lazy deletion).</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found or expired.</p> Notes <ul> <li>Uses the asynchronous connection pool.</li> <li>The value is deserialized using pickle.</li> <li>Expired entries are removed on access.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieves a value from the cache by key.\n\n    If the key does not exist or the entry has expired, returns None. If the\n    entry is expired, it is deleted from the cache (lazy deletion).\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found or expired.\n\n    Notes:\n        - Uses the asynchronous connection pool.\n        - The value is deserialized using pickle.\n        - Expired entries are removed on access.\n    \"\"\"\n    await self._ensure_async_pool_open()\n    async with self._async_pool.connection() as conn:\n        async with conn.cursor() as cur:\n            await cur.execute(\n                f\"SELECT value, expire_at FROM {self._table_name} WHERE key = %s;\",\n                (self._make_key(key),),\n            )\n            row = await cur.fetchone()\n            if not row:\n                return None\n            value, expire_at = row\n            if self._is_expired(expire_at):\n                await self.adelete(key)  # Lazy delete\n                return None\n            return pickle.loads(value)\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Uses the asynchronous connection pool.</li> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Uses the asynchronous connection pool.\n        - The key is automatically namespaced.\n    \"\"\"\n    await self._ensure_async_pool_open()\n    async with self._async_pool.connection() as conn:\n        async with conn.cursor() as cur:\n            await cur.execute(\n                f\"DELETE FROM {self._table_name} WHERE key = %s;\",\n                (self._make_key(key),),\n            )\n            await conn.commit()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously checks if a cache key exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Notes <ul> <li>Uses the asynchronous connection pool.</li> <li>Expired entries are not considered present.</li> <li>Does not remove expired entries; use <code>aget</code> for lazy deletion.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously checks if a cache key exists and is not expired.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n\n    Notes:\n        - Uses the asynchronous connection pool.\n        - Expired entries are not considered present.\n        - Does not remove expired entries; use `aget` for lazy deletion.\n    \"\"\"\n    await self._ensure_async_pool_open()\n    async with self._async_pool.connection() as conn:\n        async with conn.cursor() as cur:\n            await cur.execute(\n                f\"SELECT expire_at FROM {self._table_name} WHERE key = %s;\",\n                (self._make_key(key),),\n            )\n            row = await cur.fetchone()\n            if not row:\n                return False\n            return not self._is_expired(row[0])\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously removes all cache entries in the current namespace.</p> <p>This method deletes all rows from the cache table whose keys match the current namespace prefix.</p> Notes <ul> <li>Uses the asynchronous connection pool.</li> <li>Only entries in the current namespace are affected.</li> <li>This operation can be expensive if the cache is large.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously removes all cache entries in the current namespace.\n\n    This method deletes all rows from the cache table whose keys match the\n    current namespace prefix.\n\n    Notes:\n        - Uses the asynchronous connection pool.\n        - Only entries in the current namespace are affected.\n        - This operation can be expensive if the cache is large.\n    \"\"\"\n    await self._ensure_async_pool_open()\n    async with self._async_pool.connection() as conn:\n        async with conn.cursor() as cur:\n            # FIX: Use the dynamic table name\n            await cur.execute(\n                f\"DELETE FROM {self._table_name} WHERE key LIKE %s;\",\n                (self._make_key(\"%\"),),\n            )\n            await conn.commit()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Asynchronously closes the connection pools and stops the cleanup scheduler.</p> <p>This method should be called when the backend is no longer needed to ensure all resources are released and background jobs are stopped.</p> Notes <ul> <li>Closes both synchronous and asynchronous connection pools.</li> <li>Stops the background cleanup scheduler.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"\n    Asynchronously closes the connection pools and stops the cleanup scheduler.\n\n    This method should be called when the backend is no longer needed to ensure\n    all resources are released and background jobs are stopped.\n\n    Notes:\n        - Closes both synchronous and asynchronous connection pools.\n        - Stops the background cleanup scheduler.\n    \"\"\"\n    self._stop_cleanup_scheduler()\n    if self._sync_pool:\n        self._sync_pool.close()\n\n    if self._async_pool:\n        await self._async_pool.close()\n</code></pre>"},{"location":"api/#fast_cache.PostgresBackend.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the synchronous connection pool and stops the cleanup scheduler.</p> <p>This method should be called when the backend is no longer needed to ensure all resources are released and background jobs are stopped.</p> Notes <ul> <li>Only closes the synchronous connection pool.</li> <li>Stops the background cleanup scheduler.</li> </ul> Source code in <code>fast_cache/backends/postgres.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Closes the synchronous connection pool and stops the cleanup scheduler.\n\n    This method should be called when the backend is no longer needed to ensure\n    all resources are released and background jobs are stopped.\n\n    Notes:\n        - Only closes the synchronous connection pool.\n        - Stops the background cleanup scheduler.\n    \"\"\"\n    self._stop_cleanup_scheduler()\n    if self._sync_pool:\n        self._sync_pool.close()\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend","title":"fast_cache.MemcachedBackend","text":"<pre><code>MemcachedBackend(host, port, *, pool_size=10, pool_minsize=1, namespace='fastapi_cache')\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>Initializes a new instance of the MemcachedBackend cache.</p> <p>This backend provides a cache using Memcached as the storage layer. It supports both synchronous and asynchronous operations, and uses a namespace prefix for all keys to avoid collisions.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The hostname or IP address of the Memcached server.</p> required <code>port</code> <code>int</code> <p>The port number of the Memcached server.</p> required <code>pool_size</code> <code>int</code> <p>The maximum number of connections in the async pool. Defaults to 10.</p> <code>10</code> <code>pool_minsize</code> <code>int</code> <p>The minimum number of connections in the async pool. Defaults to 1.</p> <code>1</code> <code>namespace</code> <code>str</code> <p>Prefix for all cache keys. Defaults to \"fastapi_cache\".</p> <code>'fastapi_cache'</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the required <code>aiomcache</code> or <code>pymemcache</code> packages are not installed.</p> Notes <ul> <li>Both synchronous and asynchronous Memcached clients are initialized.</li> <li>The async client is created per event loop.</li> <li>All cache keys are automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>def __init__(\n    self,\n    host: str,\n    port: int,\n    *,\n    pool_size: int = 10,\n    pool_minsize: int = 1,\n    namespace: str = \"fastapi_cache\",\n) -&gt; None:\n    try:\n        import aiomcache\n        from pymemcache.client.base import PooledClient\n    except ImportError:\n        raise ImportError(\n            \"MemcachedBackend requires 'aiomcache' and 'pymemcache'. \"\n            \"Install with: pip install fast-cache[memcached]\"\n        )\n    self._namespace = namespace\n    self._host = host\n    self._port = port\n\n    # Sync client\n    self._sync_client = PooledClient(\n        (host, port),\n        max_pool_size=10,\n    )\n    self._async_client = aiomcache.Client(\n        host,\n        port,\n        pool_size=pool_size,\n        pool_minsize=pool_minsize,\n    )\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieves a value from the cache by key.</p> <p>If the key does not exist, returns None.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found.</p> Notes <ul> <li>The value is deserialized using pickle.</li> <li>Handles deserialization errors gracefully.</li> <li>Thread-safe for Memcached client.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieves a value from the cache by key.\n\n    If the key does not exist, returns None.\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found.\n\n    Notes:\n        - The value is deserialized using pickle.\n        - Handles deserialization errors gracefully.\n        - Thread-safe for Memcached client.\n    \"\"\"\n    try:\n        value = self._sync_client.get(self._make_key(key))\n        return pickle.loads(value) if value else None\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>The value is serialized using pickle.</li> <li>Thread-safe for Memcached client.</li> <li>Expiration is handled by Memcached.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object to cache.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - The value is serialized using pickle.\n        - Thread-safe for Memcached client.\n        - Expiration is handled by Memcached.\n    \"\"\"\n    try:\n        exptime = (\n            int(expire.total_seconds())\n            if isinstance(expire, timedelta)\n            else (expire or 0)\n        )\n        self._sync_client.set(\n            self._make_key(key), pickle.dumps(value), expire=exptime\n        )\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Thread-safe for Memcached client.</li> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Thread-safe for Memcached client.\n        - The key is automatically namespaced.\n    \"\"\"\n    try:\n        self._sync_client.delete(self._make_key(key))\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Synchronously removes all cache entries from Memcached.</p> <p>Memcached does not support namespace-based clearing, so this operation flushes the entire cache, removing all entries regardless of namespace.</p> Notes <ul> <li>Thread-safe for Memcached client.</li> <li>This operation affects all keys in the Memcached instance.</li> <li>Use with caution in shared environments.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Synchronously removes all cache entries from Memcached.\n\n    Memcached does not support namespace-based clearing, so this operation flushes\n    the entire cache, removing all entries regardless of namespace.\n\n    Notes:\n        - Thread-safe for Memcached client.\n        - This operation affects all keys in the Memcached instance.\n        - Use with caution in shared environments.\n    \"\"\"\n\n    try:\n        self._sync_client.flush_all()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously checks if a cache key exists.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Notes <ul> <li>Thread-safe for Memcached client.</li> <li>Expired entries are not considered present.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously checks if a cache key exists.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n\n    Notes:\n        - Thread-safe for Memcached client.\n        - Expired entries are not considered present.\n    \"\"\"\n    try:\n        return self._sync_client.get(self._make_key(key)) is not None\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieves a value from the cache by key.</p> <p>If the key does not exist, returns None.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found.</p> Notes <ul> <li>The value is deserialized using pickle.</li> <li>Handles deserialization errors gracefully.</li> <li>Asyncio-safe for Memcached client.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieves a value from the cache by key.\n\n    If the key does not exist, returns None.\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found.\n\n    Notes:\n        - The value is deserialized using pickle.\n        - Handles deserialization errors gracefully.\n        - Asyncio-safe for Memcached client.\n    \"\"\"\n    try:\n        value = await self._async_client.get(self._make_key(key))\n        return pickle.loads(value) if value else None\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>The value is serialized using pickle.</li> <li>Asyncio-safe for Memcached client.</li> <li>Expiration is handled by Memcached.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object to cache.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - The value is serialized using pickle.\n        - Asyncio-safe for Memcached client.\n        - Expiration is handled by Memcached.\n    \"\"\"\n    try:\n        exptime = (\n            int(expire.total_seconds())\n            if isinstance(expire, timedelta)\n            else (expire or 0)\n        )\n        await self._async_client.set(\n            self._make_key(key), pickle.dumps(value), exptime=exptime\n        )\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Asyncio-safe for Memcached client.</li> <li>The key is automatically namespaced.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Asyncio-safe for Memcached client.\n        - The key is automatically namespaced.\n    \"\"\"\n    try:\n        await self._async_client.delete(self._make_key(key))\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously removes all cache entries from Memcached.</p> <p>Memcached does not support namespace-based clearing, so this operation flushes the entire cache, removing all entries regardless of namespace.</p> Notes <ul> <li>Asyncio-safe for Memcached client.</li> <li>This operation affects all keys in the Memcached instance.</li> <li>Use with caution in shared environments.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously removes all cache entries from Memcached.\n\n    Memcached does not support namespace-based clearing, so this operation flushes\n    the entire cache, removing all entries regardless of namespace.\n\n    Notes:\n        - Asyncio-safe for Memcached client.\n        - This operation affects all keys in the Memcached instance.\n        - Use with caution in shared environments.\n    \"\"\"\n    try:\n        await self._async_client.flush_all()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously checks if a cache key exists.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Notes <ul> <li>Asyncio-safe for Memcached client.</li> <li>Expired entries are not considered present.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously checks if a cache key exists.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n\n    Notes:\n        - Asyncio-safe for Memcached client.\n        - Expired entries are not considered present.\n    \"\"\"\n    try:\n        value = await self._async_client.get(self._make_key(key))\n        return value is not None\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#fast_cache.MemcachedBackend.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Asynchronously closes both the async and sync Memcached clients.</p> <p>This method should be called when the backend is no longer needed to ensure all resources are released.</p> Notes <ul> <li>After calling this method, the backend cannot be used.</li> <li>Closes both the async and sync clients.</li> </ul> Source code in <code>fast_cache/backends/memcached.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Asynchronously closes both the async and sync Memcached clients.\n\n    This method should be called when the backend is no longer needed to ensure\n    all resources are released.\n\n    Notes:\n        - After calling this method, the backend cannot be used.\n        - Closes both the async and sync clients.\n    \"\"\"\n    try:\n        await self._async_client.close()\n        self._sync_client.close()\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend","title":"fast_cache.MongoDBBackend","text":"<pre><code>MongoDBBackend(uri, namespace='fastapi_cache')\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>MongoDB cache backend with both sync and async support. Uses a TTL index for automatic expiration of cache entries.</p> Each cache entry is stored as a document with <ul> <li>_id: the cache key (optionally namespaced)</li> <li>value: the pickled cached value</li> <li>expires_at: epoch time when the entry should expire</li> </ul> <p>Expired documents are deleted automatically by MongoDB's TTL monitor, but expiration is also checked in code to avoid returning stale data.</p> <p>Initialize the MongoDB backend.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>MongoDB connection URI (should include the database name).</p> required <code>namespace</code> <code>Optional[str]</code> <p>Optional prefix for all cache keys and the collection name.                        Defaults to \"fastapi_cache\".</p> <code>'fastapi_cache'</code> <p>Raises:     ImportError: If pymongo is not installed.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def __init__(self, uri: str, namespace: Optional[str] = \"fastapi_cache\") -&gt; None:\n    \"\"\"\n    Initialize the MongoDB backend.\n\n    Args:\n        uri (str): MongoDB connection URI (should include the database name).\n        namespace (Optional[str]): Optional prefix for all cache keys and the collection name.\n                                   Defaults to \"fastapi_cache\".\n    Raises:\n        ImportError: If pymongo is not installed.\n    \"\"\"\n    try:\n        import pymongo\n    except ImportError:\n        raise ImportError(\n            \"MongoDBBackend requires 'pymongo&gt;=4.6.0'. \"\n            \"Install with: pip install fastapi-cachekit[mongodb]\"\n        )\n    self._namespace = namespace or \"cache\"\n\n    self._sync_client = pymongo.MongoClient(uri)\n    self._sync_db = self._sync_client.get_default_database()\n    self._sync_collection = self._sync_db[self._namespace]\n    self._sync_collection.create_index(\"expires_at\", expireAfterSeconds=0)\n\n    # Async client\n    self._async_client = pymongo.AsyncMongoClient(uri)\n    self._async_db = self._async_client.get_default_database()\n    self._async_collection = self._async_db[self._namespace]\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found or expired.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The cache key.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found or expired.\n    \"\"\"\n    doc = self._sync_collection.find_one({\"_id\": self._make_key(key)})\n    if doc and (doc.get(\"expires_at\", float(\"inf\")) &gt; time.time()):\n        try:\n            return pickle.loads(doc[\"value\"])\n        except Exception:\n            return None\n    return None\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required <code>value</code> <code>Any</code> <p>The value to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.                                      If None, the entry never expires.</p> <code>None</code> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously set a value in the cache.\n\n    Args:\n        key (str): The cache key.\n        value (Any): The value to cache.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n                                                 If None, the entry never expires.\n    \"\"\"\n    update = {\"value\": pickle.dumps(value)}\n    exptime = self._compute_expire_at(expire)\n    if exptime is not None:\n        update[\"expires_at\"] = exptime\n\n    self._sync_collection.update_one(\n        {\"_id\": self._make_key(key)}, {\"$set\": update}, upsert=True\n    )\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously delete a value from the cache.\n\n    Args:\n        key (str): The cache key.\n    \"\"\"\n    self._sync_collection.delete_one({\"_id\": self._make_key(key)})\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Synchronously clear all values from the namespace.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Synchronously clear all values from the namespace.\n    \"\"\"\n    self._sync_collection.delete_many({\"_id\": {\"$regex\": f\"^{self._namespace}:\"}})\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The cache key.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n    \"\"\"\n    doc = self._sync_collection.find_one({\"_id\": self._make_key(key)})\n    return bool(doc and (doc.get(\"expires_at\", float(\"inf\")) &gt; time.time()))\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found or expired.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The cache key.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found or expired.\n    \"\"\"\n    doc = await self._async_collection.find_one({\"_id\": self._make_key(key)})\n    if doc and (doc.get(\"expires_at\", float(\"inf\")) &gt; time.time()):\n        try:\n            return pickle.loads(doc[\"value\"])\n        except Exception:\n            return None\n    return None\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required <code>value</code> <code>Any</code> <p>The value to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.                                      If None, the entry never expires.</p> <code>None</code> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously set a value in the cache.\n\n    Args:\n        key (str): The cache key.\n        value (Any): The value to cache.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n                                                 If None, the entry never expires.\n    \"\"\"\n    update = {\"value\": pickle.dumps(value)}\n    exptime = self._compute_expire_at(expire)\n    if exptime is not None:\n        update[\"expires_at\"] = exptime\n\n    await self._async_collection.update_one(\n        {\"_id\": self._make_key(key)}, {\"$set\": update}, upsert=True\n    )\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously delete a value from the cache.\n\n    Args:\n        key (str): The cache key.\n    \"\"\"\n    await self._async_collection.delete_one({\"_id\": self._make_key(key)})\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously clear all values from the namespace.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously clear all values from the namespace.\n    \"\"\"\n    await self._async_collection.delete_many(\n        {\"_id\": {\"$regex\": f\"^{self._namespace}:\"}}\n    )\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The cache key.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n    \"\"\"\n    doc = await self._async_collection.find_one({\"_id\": self._make_key(key)})\n    return bool(doc and (doc.get(\"expires_at\", float(\"inf\")) &gt; time.time()))\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the synchronous MongoDB client.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Close the synchronous MongoDB client.\n    \"\"\"\n    self._sync_client.close()\n</code></pre>"},{"location":"api/#fast_cache.MongoDBBackend.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Close the asynchronous MongoDB client.</p> Source code in <code>fast_cache/backends/mongodb.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"\n    Close the asynchronous MongoDB client.\n    \"\"\"\n    self._sync_client.close()\n    await self._async_client.close()\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend","title":"fast_cache.FirestoreBackend","text":"<pre><code>FirestoreBackend(credential_path=None, namespace='fastapi_cache', collection_name='cache_entries', cleanup_interval=30, auto_cleanup=True)\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>Initializes a new instance of the FirestoreBackend cache.</p> <p>This backend provides a cache using Google Cloud Firestore as the storage layer. It supports both synchronous and asynchronous operations, manual expiration management, and optional periodic cleanup of expired entries.</p> <p>Parameters:</p> Name Type Description Default <code>credential_path</code> <code>Optional[str]</code> <p>Path to the Firebase Admin SDK credentials file. If None, uses the GOOGLE_APPLICATION_CREDENTIALS environment variable. Defaults to None.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>Optional prefix for all cache keys. Defaults to \"fastapi_cache\".</p> <code>'fastapi_cache'</code> <code>collection_name</code> <code>Optional[str]</code> <p>Name of the Firestore collection to use for storing cache entries. Defaults to \"cache_entries\".</p> <code>'cache_entries'</code> <code>cleanup_interval</code> <code>int</code> <p>Interval in seconds for periodic cleanup of expired entries. Defaults to 30.</p> <code>30</code> <code>auto_cleanup</code> <code>bool</code> <p>Whether to automatically start the cleanup scheduler on initialization. Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the required <code>google-cloud-firestore</code> package is not installed.</p> Notes <ul> <li>The backend uses a hashed, namespaced key for each Firestore document.</li> <li>Expired entries are managed via a custom <code>expires_at</code> field.</li> <li>Both synchronous and asynchronous Firestore clients are initialized.</li> <li>The cleanup scheduler can be started or stopped manually.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def __init__(\n    self,\n    credential_path: Optional[str] = None,\n    namespace: Optional[str] = \"fastapi_cache\",\n    collection_name: Optional[str] = \"cache_entries\",\n    cleanup_interval: int = 30,\n    auto_cleanup: bool = True,\n) -&gt; None:\n    try:\n        from google.oauth2 import service_account\n        from google.cloud import firestore\n        from google.cloud.firestore_v1.async_client import AsyncClient\n        from google.cloud.firestore_v1.client import Client\n    except ImportError:\n        raise ImportError(\n            \"FirestoreBackend requires 'google-cloud-firestore'. \"\n            \"Install with: pip install fastapi-cachekit[firestore]\"\n        )\n\n    self._namespace = namespace or \"cache\"\n    self._collection_name = collection_name or \"cache_entries\"\n\n    self._cleanup_task = None\n    self._cleanup_interval = cleanup_interval\n    self._auto_cleanup = auto_cleanup\n\n    self._scheduler = None\n    self._scheduler_lock = threading.Lock()\n\n    if credential_path:\n        # Explicitly load credentials from the provided path\n        credentials = service_account.Credentials.from_service_account_file(\n            credential_path\n        )\n        self._sync_db: Client = firestore.Client(credentials=credentials)\n        self._async_db: AsyncClient = firestore.AsyncClient(credentials=credentials)\n    else:\n        # Rely on GOOGLE_APPLICATION_CREDENTIALS\n        self._sync_db: Client = firestore.Client()\n        self._async_db: AsyncClient = firestore.AsyncClient()\n\n    if self._auto_cleanup:\n        self._start_cleanup_scheduler()\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieves a value from the cache by key.</p> <p>If the key does not exist or the entry has expired, returns None. If the entry is expired, it is not automatically deleted.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found or expired.</p> Notes <ul> <li>The value is deserialized using pickle.</li> <li>Handles deserialization errors gracefully.</li> <li>Thread-safe for Firestore client.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieves a value from the cache by key.\n\n    If the key does not exist or the entry has expired, returns None. If the\n    entry is expired, it is not automatically deleted.\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found or expired.\n\n    Notes:\n        - The value is deserialized using pickle.\n        - Handles deserialization errors gracefully.\n        - Thread-safe for Firestore client.\n    \"\"\"\n    doc_ref = self._sync_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    doc = doc_ref.get()\n    if doc.exists:\n        data = doc.to_dict()\n        if not self._is_expired(data.get(\"expires_at\")):\n            try:\n                return pickle.loads(data[\"value\"])\n            except (pickle.UnpicklingError, KeyError):\n                return None\n    return None\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>The value is serialized using pickle.</li> <li>Thread-safe for Firestore client.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object to cache.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - The value is serialized using pickle.\n        - Thread-safe for Firestore client.\n    \"\"\"\n    doc_ref = self._sync_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    data = {\"value\": pickle.dumps(value)}\n    exptime = self._compute_expire_at(expire)\n    if exptime is not None:\n        data[\"expires_at\"] = exptime\n\n    doc_ref.set(data)\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Thread-safe for Firestore client.</li> <li>The key is automatically namespaced and hashed.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Thread-safe for Firestore client.\n        - The key is automatically namespaced and hashed.\n    \"\"\"\n    doc_ref = self._sync_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    doc_ref.delete()\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Synchronously removes all cache entries in the collection.</p> <p>This method deletes all documents in the configured Firestore collection. Note that Firestore does not support direct namespace-based clearing, so all entries in the collection are removed.</p> Notes <ul> <li>Thread-safe for Firestore client.</li> <li>This operation can be expensive if the collection is large.</li> <li>For more granular clearing, consider adding a namespace field to documents.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Synchronously removes all cache entries in the collection.\n\n    This method deletes all documents in the configured Firestore collection.\n    Note that Firestore does not support direct namespace-based clearing, so\n    all entries in the collection are removed.\n\n    Notes:\n        - Thread-safe for Firestore client.\n        - This operation can be expensive if the collection is large.\n        - For more granular clearing, consider adding a namespace field to documents.\n    \"\"\"\n    docs = self._sync_db.collection(self._collection_name).stream()\n    for doc in docs:\n        doc.reference.delete()\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously checks if a cache key exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Notes <ul> <li>Thread-safe for Firestore client.</li> <li>Expired entries are not considered present.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously checks if a cache key exists and is not expired.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n\n    Notes:\n        - Thread-safe for Firestore client.\n        - Expired entries are not considered present.\n    \"\"\"\n    doc_ref = self._sync_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    doc = doc_ref.get()\n    if doc.exists:\n        data = doc.to_dict()\n        return not self._is_expired(data.get(\"expires_at\"))\n    return False\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieves a value from the cache by key.</p> <p>If the key does not exist or the entry has expired, returns None. If the entry is expired, it is not automatically deleted.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached Python object, or None if not found or expired.</p> Notes <ul> <li>The value is deserialized using pickle.</li> <li>Handles deserialization errors gracefully.</li> <li>Asyncio-safe for Firestore client.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieves a value from the cache by key.\n\n    If the key does not exist or the entry has expired, returns None. If the\n    entry is expired, it is not automatically deleted.\n\n    Args:\n        key (str): The cache key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached Python object, or None if not found or expired.\n\n    Notes:\n        - The value is deserialized using pickle.\n        - Handles deserialization errors gracefully.\n        - Asyncio-safe for Firestore client.\n    \"\"\"\n    doc_ref = self._async_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    doc = await doc_ref.get()\n    if doc.exists:\n        data = doc.to_dict()\n        if not self._is_expired(data.get(\"expires_at\")):\n            try:\n                return pickle.loads(data[\"value\"])\n            except (pickle.UnpicklingError, KeyError):\n                # Handle potential deserialization errors or missing value field\n                return None\n    return None\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously stores a value in the cache under the specified key.</p> <p>If the key already exists, its value and expiration time are updated. Optionally, an expiration time can be set, after which the entry will be considered expired and eligible for deletion.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to store the value under.</p> required <code>value</code> <code>Any</code> <p>The Python object to cache.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>The expiration time for the cache entry. Can be specified as an integer (seconds) or a timedelta. If None, the entry does not expire.</p> <code>None</code> Notes <ul> <li>The value is serialized using pickle.</li> <li>Asyncio-safe for Firestore client.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously stores a value in the cache under the specified key.\n\n    If the key already exists, its value and expiration time are updated.\n    Optionally, an expiration time can be set, after which the entry will be\n    considered expired and eligible for deletion.\n\n    Args:\n        key (str): The cache key to store the value under.\n        value (Any): The Python object to cache.\n        expire (Optional[Union[int, timedelta]], optional): The expiration time\n            for the cache entry. Can be specified as an integer (seconds) or a\n            timedelta. If None, the entry does not expire.\n\n    Notes:\n        - The value is serialized using pickle.\n        - Asyncio-safe for Firestore client.\n    \"\"\"\n    doc_ref = self._async_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    data = {\"value\": pickle.dumps(value)}\n    exptime = self._compute_expire_at(expire)\n\n    if expire is not None:\n        data[\"expires_at\"] = exptime\n\n    await doc_ref.set(data)\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously deletes a cache entry by key.</p> <p>If the key does not exist, this method does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to delete.</p> required Notes <ul> <li>Asyncio-safe for Firestore client.</li> <li>The key is automatically namespaced and hashed.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously deletes a cache entry by key.\n\n    If the key does not exist, this method does nothing.\n\n    Args:\n        key (str): The cache key to delete.\n\n    Notes:\n        - Asyncio-safe for Firestore client.\n        - The key is automatically namespaced and hashed.\n    \"\"\"\n    doc_ref = self._async_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    await doc_ref.delete()\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously removes all cache entries in the collection.</p> <p>This method deletes all documents in the configured Firestore collection. Note that Firestore does not support direct namespace-based clearing, so all entries in the collection are removed.</p> Notes <ul> <li>Asyncio-safe for Firestore client.</li> <li>This operation can be expensive if the collection is large.</li> <li>For more granular clearing, consider adding a namespace field to documents.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously removes all cache entries in the collection.\n\n    This method deletes all documents in the configured Firestore collection.\n    Note that Firestore does not support direct namespace-based clearing, so\n    all entries in the collection are removed.\n\n    Notes:\n        - Asyncio-safe for Firestore client.\n        - This operation can be expensive if the collection is large.\n        - For more granular clearing, consider adding a namespace field to documents.\n    \"\"\"\n    docs = self._async_db.collection(self._collection_name).stream()\n    async for doc in docs:\n        await doc.reference.delete()\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously checks if a cache key exists and is not expired.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The cache key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists and is not expired, False otherwise.</p> Notes <ul> <li>Asyncio-safe for Firestore client.</li> <li>Expired entries are not considered present.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously checks if a cache key exists and is not expired.\n\n    Args:\n        key (str): The cache key to check.\n\n    Returns:\n        bool: True if the key exists and is not expired, False otherwise.\n\n    Notes:\n        - Asyncio-safe for Firestore client.\n        - Expired entries are not considered present.\n    \"\"\"\n    doc_ref = self._async_db.collection(self._collection_name).document(\n        self._make_key(key)\n    )\n    doc = await doc_ref.get()\n    if doc.exists:\n        data = doc.to_dict()\n        return not self._is_expired(data.get(\"expires_at\"))\n    return False\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Closes the synchronous Firestore client and stops the cleanup scheduler.</p> <p>This method should be called when the backend is no longer needed to ensure all resources are released and background jobs are stopped.</p> Notes <ul> <li>After calling this method, the synchronous client is closed and cannot be used.</li> <li>The background cleanup scheduler is stopped.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"\n    Closes the synchronous Firestore client and stops the cleanup scheduler.\n\n    This method should be called when the backend is no longer needed to ensure\n    all resources are released and background jobs are stopped.\n\n    Notes:\n        - After calling this method, the synchronous client is closed and cannot be used.\n        - The background cleanup scheduler is stopped.\n    \"\"\"\n    self._stop_cleanup_scheduler()\n    try:\n        self._sync_db.close()\n    except TypeError:\n        return\n</code></pre>"},{"location":"api/#fast_cache.FirestoreBackend.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Closes the asynchronous Firestore client and stops the cleanup scheduler.</p> <p>This method should be called when the backend is no longer needed to ensure all resources are released and background jobs are stopped.</p> Notes <ul> <li>After calling this method, the asynchronous client is closed and cannot be used.</li> <li>The background cleanup scheduler is stopped.</li> </ul> Source code in <code>fast_cache/backends/google_firestore.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"\n    Closes the asynchronous Firestore client and stops the cleanup scheduler.\n\n    This method should be called when the backend is no longer needed to ensure\n    all resources are released and background jobs are stopped.\n\n    Notes:\n        - After calling this method, the asynchronous client is closed and cannot be used.\n        - The background cleanup scheduler is stopped.\n    \"\"\"\n    self._stop_cleanup_scheduler()\n    try:\n        await self._async_db.close()\n    except TypeError:\n        return\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend","title":"fast_cache.DynamoDBBackend","text":"<pre><code>DynamoDBBackend(table_name, region_name, namespace='cache', aws_access_key_id=None, aws_secret_access_key=None, endpoint_url=None, create_table=True)\n</code></pre> <p>               Bases: <code>CacheBackend</code></p> <p>DynamoDB cache backend implementation with namespace support.</p> <p>Attributes:</p> Name Type Description <code>_namespace</code> <code>str</code> <p>Namespace prefix for all keys.</p> <code>_table_name</code> <code>str</code> <p>DynamoDB table name.</p> <code>_sync_client</code> <code>client</code> <p>Synchronous DynamoDB client.</p> <code>_async_client</code> <code>client</code> <p>Asynchronous DynamoDB client.</p> <code>_sync_resource</code> <code>resource</code> <p>Synchronous DynamoDB resource.</p> <code>_async_resource</code> <code>resource</code> <p>Asynchronous DynamoDB resource.</p> <p>Initialize DynamoDB backend with table and connection settings.</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>DynamoDB table name for cache storage.</p> required <code>namespace</code> <code>str</code> <p>Namespace prefix for all keys (default: \"fastapi-cache\").</p> <code>'cache'</code> <code>region_name</code> <code>str</code> <p>AWS region name (default: \"us-east-1\").</p> required <code>aws_access_key_id</code> <code>Optional[str]</code> <p>AWS access key ID.</p> <code>None</code> <code>aws_secret_access_key</code> <code>Optional[str]</code> <p>AWS secret access key.</p> <code>None</code> <code>endpoint_url</code> <code>Optional[str]</code> <p>Custom endpoint URL (for local DynamoDB).</p> <code>None</code> <code>create_table</code> <code>bool</code> <p>Whether to create table if it doesn't exist.</p> <code>True</code> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>def __init__(\n    self,\n    table_name: str,\n    region_name: str,\n    namespace: str = \"cache\",\n    aws_access_key_id: Optional[str] = None,\n    aws_secret_access_key: Optional[str] = None,\n    endpoint_url: Optional[str] = None,\n    create_table: bool = True,\n) -&gt; None:\n    \"\"\"\n    Initialize DynamoDB backend with table and connection settings.\n\n    Args:\n        table_name (str): DynamoDB table name for cache storage.\n        namespace (str): Namespace prefix for all keys (default: \"fastapi-cache\").\n        region_name (str): AWS region name (default: \"us-east-1\").\n        aws_access_key_id (Optional[str]): AWS access key ID.\n        aws_secret_access_key (Optional[str]): AWS secret access key.\n        endpoint_url (Optional[str]): Custom endpoint URL (for local DynamoDB).\n        create_table (bool): Whether to create table if it doesn't exist.\n    \"\"\"\n    try:\n        import boto3\n        import aioboto3\n    except ImportError:\n        raise ImportError(\n            \"DynamoDBBackend requires the 'boto3' and 'aioboto3' packages. \"\n            \"Install them with: pip install fast-cache[dynamodb]\"\n        )\n\n    self._namespace = namespace\n    self._table_name = table_name\n\n    # Connection parameters\n    self._connection_params = {\n        \"region_name\": region_name,\n        \"endpoint_url\": endpoint_url,\n    }\n\n    if aws_access_key_id and aws_secret_access_key:\n        self._connection_params.update(\n            {\n                \"aws_access_key_id\": aws_access_key_id,\n                \"aws_secret_access_key\": aws_secret_access_key,\n            }\n        )\n\n    # Sync client for table management only\n    self._sync_client = boto3.client(\"dynamodb\", **self._connection_params)\n\n    # Sync resource/table for sync cache operations\n    self._sync_resource = boto3.resource(\"dynamodb\", **self._connection_params)\n    self._sync_table = self._sync_resource.Table(table_name)\n\n    # Initialize async session\n    self._async_resource = None\n    self._async_table = None\n    self._async_session = aioboto3.Session()\n\n    # Create table if requested\n    if create_table:\n        self._ensure_table_exists()\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.get","title":"get","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>def get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found.\n    \"\"\"\n    try:\n        response = self._sync_table.get_item(Key={\"cache_key\": self._make_key(key)})\n\n        if \"Item\" not in response:\n            return None\n\n        item = response[\"Item\"]\n\n        # Check if item has expired and delete if so\n        if self._is_expired(item):\n            self.delete(key)\n            return None\n        value = self._deserialize_value(item[\"value\"])\n        return value\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.aget","title":"aget  <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>async def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found.\n    \"\"\"\n    try:\n        table = await self._get_async_table()\n        response = await table.get_item(Key={\"cache_key\": self._make_key(key)})\n\n        if \"Item\" not in response:\n            return None\n\n        item = response[\"Item\"]\n\n        # Check if item has expired and delete if so\n        if self._is_expired(item):\n            await self.adelete(key)\n            return None\n\n        return self._deserialize_value(item[\"value\"])\n    except Exception:\n        return None\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.set","title":"set","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>Any</code> <p>The value to store.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.</p> <code>None</code> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>def set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously set a value in the cache.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (Any): The value to store.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n    \"\"\"\n    try:\n        item = self._build_item(key, value, expire)\n        self._sync_table.put_item(Item=item)\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.aset","title":"aset  <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>Any</code> <p>The value to store.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.</p> <code>None</code> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>async def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously set a value in the cache.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (Any): The value to store.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n    \"\"\"\n    try:\n        table = await self._get_async_table()\n        item = self._build_item(key, value, expire)\n        await table.put_item(Item=item)\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.delete","title":"delete","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>def delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously delete a value from the cache.\n\n    Args:\n        key (str): The key to delete.\n    \"\"\"\n    try:\n        self._sync_table.delete_item(Key={\"cache_key\": self._make_key(key)})\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.adelete","title":"adelete  <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>async def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously delete a value from the cache.\n\n    Args:\n        key (str): The key to delete.\n    \"\"\"\n    try:\n        table = await self._get_async_table()\n        await table.delete_item(Key={\"cache_key\": self._make_key(key)})\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.has","title":"has","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>def has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    try:\n        response = self._sync_table.get_item(\n            Key={\"cache_key\": self._make_key(key)},\n            ProjectionExpression=\"cache_key, #ttl\",\n            ExpressionAttributeNames={\"#ttl\": \"ttl\"},\n        )\n\n        if \"Item\" not in response:\n            return False\n\n        item = response[\"Item\"]\n\n        # Check if item has expired and delete if so\n        if self._is_expired(item):\n            self.delete(key)\n            return False\n\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.ahas","title":"ahas  <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>async def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    try:\n        table = await self._get_async_table()\n        response = await table.get_item(\n            Key={\"cache_key\": self._make_key(key)},\n            ProjectionExpression=\"cache_key, #ttl\",\n            ExpressionAttributeNames={\"#ttl\": \"ttl\"},\n        )\n\n        if \"Item\" not in response:\n            return False\n\n        item = response[\"Item\"]\n\n        # Check if item has expired and delete if so\n        if self._is_expired(item):\n            await self.adelete(key)\n            return False\n\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.clear","title":"clear","text":"<pre><code>clear()\n</code></pre> <p>Synchronously clear all values from the namespace.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Synchronously clear all values from the namespace.\n    \"\"\"\n    try:\n        # Scan for all items with the namespace prefix\n        response = self._sync_table.scan(\n            FilterExpression=\"begins_with(cache_key, :prefix)\",\n            ExpressionAttributeValues={\":prefix\": f\"{self._namespace}:\"},\n            ProjectionExpression=\"cache_key\",\n        )\n\n        # Delete items in batches\n        if response.get(\"Items\"):\n            with self._sync_table.batch_writer() as batch:\n                for item in response[\"Items\"]:\n                    batch.delete_item(Key={\"cache_key\": item[\"cache_key\"]})\n\n        # Handle pagination\n        while \"LastEvaluatedKey\" in response:\n            response = self._sync_table.scan(\n                FilterExpression=\"begins_with(cache_key, :prefix)\",\n                ExpressionAttributeValues={\":prefix\": f\"{self._namespace}:\"},\n                ProjectionExpression=\"cache_key\",\n                ExclusiveStartKey=response[\"LastEvaluatedKey\"],\n            )\n\n            if response.get(\"Items\"):\n                with self._sync_table.batch_writer() as batch:\n                    for item in response[\"Items\"]:\n                        batch.delete_item(Key={\"cache_key\": item[\"cache_key\"]})\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.aclear","title":"aclear  <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously clear all values from the namespace.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>async def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously clear all values from the namespace.\n    \"\"\"\n    try:\n        table = await self._get_async_table()\n\n        # Scan for all items with the namespace prefix\n        response = await table.scan(\n            FilterExpression=\"begins_with(cache_key, :prefix)\",\n            ExpressionAttributeValues={\":prefix\": f\"{self._namespace}:\"},\n            ProjectionExpression=\"cache_key\",\n        )\n\n        # Delete items in batches\n        if response.get(\"Items\"):\n            async with table.batch_writer() as batch:\n                for item in response[\"Items\"]:\n                    await batch.delete_item(Key={\"cache_key\": item[\"cache_key\"]})\n\n        # Handle pagination\n        while \"LastEvaluatedKey\" in response:\n            response = await table.scan(\n                FilterExpression=\"begins_with(cache_key, :prefix)\",\n                ExpressionAttributeValues={\":prefix\": f\"{self._namespace}:\"},\n                ProjectionExpression=\"cache_key\",\n                ExclusiveStartKey=response[\"LastEvaluatedKey\"],\n            )\n\n            if response.get(\"Items\"):\n                async with table.batch_writer() as batch:\n                    for item in response[\"Items\"]:\n                        await batch.delete_item(\n                            Key={\"cache_key\": item[\"cache_key\"]}\n                        )\n\n    except Exception:\n        pass\n</code></pre>"},{"location":"api/#fast_cache.DynamoDBBackend.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close DynamoDB connections and clean up resources.</p> Source code in <code>fast_cache/backends/dynamodb.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"\n    Close DynamoDB connections and clean up resources.\n    \"\"\"\n    if self._async_resource:\n        await self._async_resource.__aexit__(None, None, None)\n        self._async_resource = None\n        self._async_table = None\n</code></pre>"},{"location":"api/#backend-base-class","title":"Backend Base Class","text":""},{"location":"api/#fast_cache.backends.backend.CacheBackend","title":"fast_cache.backends.backend.CacheBackend","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for cache backends.</p> <p>All cache backend implementations must inherit from this class and implement both synchronous and asynchronous methods for cache operations.</p>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.aget","title":"aget  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>aget(key)\n</code></pre> <p>Asynchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found.</p> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\nasync def aget(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Asynchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key)\n</code></pre> <p>Synchronously retrieve a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[Any]</code> <p>Optional[Any]: The cached value, or None if not found.</p> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\ndef get(self, key: str) -&gt; Optional[Any]:\n    \"\"\"\n    Synchronously retrieve a value from the cache.\n\n    Args:\n        key (str): The key to retrieve.\n\n    Returns:\n        Optional[Any]: The cached value, or None if not found.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.aset","title":"aset  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>aset(key, value, expire=None)\n</code></pre> <p>Asynchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>Any</code> <p>The value to store.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.</p> <code>None</code> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\nasync def aset(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Asynchronously set a value in the cache.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (Any): The value to store.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.set","title":"set  <code>abstractmethod</code>","text":"<pre><code>set(key, value, expire=None)\n</code></pre> <p>Synchronously set a value in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key under which to store the value.</p> required <code>value</code> <code>Any</code> <p>The value to store.</p> required <code>expire</code> <code>Optional[Union[int, timedelta]]</code> <p>Expiration time in seconds or as timedelta.</p> <code>None</code> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\ndef set(\n    self, key: str, value: Any, expire: Optional[Union[int, timedelta]] = None\n) -&gt; None:\n    \"\"\"\n    Synchronously set a value in the cache.\n\n    Args:\n        key (str): The key under which to store the value.\n        value (Any): The value to store.\n        expire (Optional[Union[int, timedelta]]): Expiration time in seconds or as timedelta.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.adelete","title":"adelete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>adelete(key)\n</code></pre> <p>Asynchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\nasync def adelete(self, key: str) -&gt; None:\n    \"\"\"\n    Asynchronously delete a value from the cache.\n\n    Args:\n        key (str): The key to delete.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.delete","title":"delete  <code>abstractmethod</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Synchronously delete a value from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to delete.</p> required Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\ndef delete(self, key: str) -&gt; None:\n    \"\"\"\n    Synchronously delete a value from the cache.\n\n    Args:\n        key (str): The key to delete.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.aclear","title":"aclear  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>aclear()\n</code></pre> <p>Asynchronously clear all values from the cache.</p> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\nasync def aclear(self) -&gt; None:\n    \"\"\"\n    Asynchronously clear all values from the cache.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.clear","title":"clear  <code>abstractmethod</code>","text":"<pre><code>clear()\n</code></pre> <p>Synchronously clear all values from the cache.</p> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\ndef clear(self) -&gt; None:\n    \"\"\"\n    Synchronously clear all values from the cache.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.ahas","title":"ahas  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>ahas(key)\n</code></pre> <p>Asynchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\nasync def ahas(self, key: str) -&gt; bool:\n    \"\"\"\n    Asynchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#fast_cache.backends.backend.CacheBackend.has","title":"has  <code>abstractmethod</code>","text":"<pre><code>has(key)\n</code></pre> <p>Synchronously check if a key exists in the cache.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists, False otherwise.</p> Source code in <code>fast_cache/backends/backend.py</code> <pre><code>@abstractmethod\ndef has(self, key: str) -&gt; bool:\n    \"\"\"\n    Synchronously check if a key exists in the cache.\n\n    Args:\n        key (str): The key to check.\n\n    Returns:\n        bool: True if the key exists, False otherwise.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"backends/","title":"\ud83d\uddc4\ufe0f Backends Overview","text":"<p>FastAPI Cachekit supports multiple cache backends, so you can choose the best fit for your application\u2019s needs\u2014whether you want blazing-fast in-memory caching for development, or distributed caching for production.</p>"},{"location":"backends/#supported-backends","title":"Supported Backends","text":"Backend Description Best For Docs InMemoryBackend Stores cache in the app\u2019s memory (LRU support) Development, testing In-Memory RedisBackend Uses Redis for distributed, production caching Production, scaling Redis PostgresBackend Uses PostgreSQL for persistent SQL-based caching Data persistence, SQL Postgres MemcachedBackend Uses Memcached for high-speed distributed caching High-speed, stateless Memcached MongoDBBackend Uses MongoDB for document-based distributed caching NoSQL, flexible schema MongoDB FirestoreBackend Uses Google Firestore for serverless NoSQL caching Serverless, GCP users Firestore DynamoDBBackend Uses AWS DynamoDB for serverless NoSQL caching Serverless, AWS users DynamoDB ---"},{"location":"backends/#how-to-choose-a-backend","title":"How to Choose a Backend","text":"<ul> <li>InMemoryBackend </li> <li>\ud83d\udfe2 Easiest to set up, no extra dependencies.</li> <li>\ud83d\udfe1 Not shared between processes or servers.</li> <li> <p>\ud83d\udfe1 Data lost on restart.</p> </li> <li> <p>RedisBackend </p> </li> <li>\ud83d\udfe2 Distributed, scalable, and fast.</li> <li>\ud83d\udfe2 Widely used in production.</li> <li> <p>\ud83d\udfe1 Requires a running Redis server.</p> </li> <li> <p>PostgresBackend </p> </li> <li>\ud83d\udfe2 Uses your existing PostgreSQL database.</li> <li>\ud83d\udfe2 Data persists across restarts.</li> <li> <p>\ud83d\udfe1 Slightly slower than in-memory or Redis.</p> </li> <li> <p>MemcachedBackend </p> </li> <li>\ud83d\udfe2 High-speed, distributed, simple.</li> <li>\ud83d\udfe1 No persistence (data lost on restart).</li> <li> <p>\ud83d\udfe1 No built-in authentication by default.</p> </li> <li> <p>MongoDBBackend</p> </li> <li>\ud83d\udfe2 Persistent storage (data survives restarts).</li> <li>\ud83d\udfe2 Built-in TTL index for automatic cache expiration.</li> <li>\ud83d\udfe2 Supports authentication and access control.</li> <li> <p>\ud83d\udfe1 Slower than in-memory caches (e.g., Memcached).</p> </li> <li> <p>FirestoreBackend</p> </li> <li>\ud83d\udfe2 Persistent, serverless NoSQL storage (data survives restarts).</li> <li>\ud83d\udfe2 Native TTL support for automatic cache expiration.</li> <li>\ud83d\udfe2 Scales automatically with Google Cloud infrastructure.</li> <li>\ud83d\udfe2 Supports authentication and fine-grained access control.</li> <li>\ud83d\udfe1 Slightly higher latency compared to in-memory caches.</li> <li> <p>\ud83d\udfe1 Requires Google Cloud project and credentials.</p> </li> <li> <p>DynamoDBBackend</p> </li> <li>\ud83d\udfe2 Persistent, serverless NoSQL storage (data survives restarts).</li> <li>\ud83d\udfe2 Native TTL support for automatic cache expiration.</li> <li>\ud83d\udfe2 Scales automatically with AWS infrastructure.</li> <li>\ud83d\udfe2 Supports IAM authentication and access control.</li> <li>\ud83d\udfe1 Slightly higher latency compared to in-memory caches.</li> <li>\ud83d\udfe1 Requires AWS account and credentials.</li> </ul>"},{"location":"backends/#installation-for-each-backend","title":"Installation for Each Backend","text":"<p>See the Installation Guide for details on installing optional dependencies for each backend.</p>"},{"location":"backends/#backend-setup-guides","title":"Backend Setup Guides","text":"<ul> <li>In-Memory Backend</li> <li>Redis Backend</li> <li>Postgres Backend</li> <li>Memcached Backend</li> <li>MongoDB Backend</li> <li>Firestore Backend</li> <li>DynamoDB Backend</li> </ul>"},{"location":"backends/#adding-more-backends","title":"Adding More Backends","text":"<p>Want to add support for another backend? Open an issue or submit a pull request on GitHub!</p> <p>FastAPI Cachekit makes it easy to switch backends with minimal code changes\u2014just swap the backend class and you\u2019re ready to go!</p>"},{"location":"installation/","title":"\ud83d\ude80 Installation","text":"<p>FastAPI Cachekit is designed to be easy to install and flexible for any workflow. You can use pip, uv, or poetry and only install the backends you need.</p>"},{"location":"installation/#basic-installation-in-memory-only","title":"\ud83d\udce6 Basic Installation (In-Memory Only)","text":"<p>Install the core package (in-memory backend only):</p> <ul> <li>pip <code>pip install fastapi-cachekit</code></li> <li>uv <code>uv add fastapi-cachekit</code></li> <li>poetry <code>poetry add fastapi-cachekit</code></li> </ul>"},{"location":"installation/#optional-backends","title":"\ud83d\udd0c Optional Backends","text":"<p>You can install support for Redis, Postgres, MongoDB, Memcached, Firestore, DynamoDB by specifying the appropriate \"extra\".</p>"},{"location":"installation/#redis-backend","title":"Redis Backend","text":"<ul> <li>pip <code>pip install fastapi-cachekit[redis]</code></li> <li>uv <code>uv add fastapi-cachekit[redis]</code></li> <li>poetry <code>poetry add fastapi-cachekit -E redis</code></li> </ul>"},{"location":"installation/#postgres-backend","title":"Postgres Backend","text":"<ul> <li>pip <code>pip install fastapi-cachekit[postgres]</code></li> <li>uv <code>uv add fastapi-cachekit[postgres]</code></li> <li>poetry <code>poetry add fastapi-cachekit -E postgres</code></li> </ul>"},{"location":"installation/#memcached-backend","title":"Memcached Backend","text":"<ul> <li>pip <code>pip install fastapi-cachekit[memcached]</code></li> <li>uv <code>uv add fastapi-cachekit[memcached]</code></li> <li>poetry <code>poetry add fastapi-cachekit -E memcached</code></li> </ul>"},{"location":"installation/#mongodb-backend","title":"MongoDB Backend","text":"<ul> <li>pip <code>pip install fastapi-cachekit[mongodb]</code></li> <li>uv <code>uv add fastapi-cachekit[mongodb]</code></li> <li>poetry <code>poetry add fastapi-cachekit -E mongodb</code></li> </ul>"},{"location":"installation/#firestore-backend","title":"FireStore Backend","text":"<ul> <li>pip <code>pip install fastapi-cachekit[firestore]</code></li> <li>uv <code>uv add fastapi-cachekit[firestore]</code></li> <li>poetry <code>poetry add fastapi-cachekit -E firestore</code></li> </ul>"},{"location":"installation/#dynamodb-backend","title":"DynamoDB Backend","text":"<ul> <li>pip <code>pip install fastapi-cachekit[dynamodb]</code></li> <li>uv <code>uv add fastapi-cachekit[dynamodb]</code></li> <li>poetry <code>poetry add fastapi-cachekit -E dynamodb</code></li> </ul>"},{"location":"installation/#install-all-backends","title":"\ud83e\udde9 Install All Backends","text":"<p>If you want to install all supported backends at once:</p> <ul> <li> <p>pip <code>pip install fastapi-cachekit[all]</code></p> </li> <li> <p>uv <code>uv add fastapi-cachekit[all]</code></p> </li> <li> <p>poetry <code>poetry add fastapi-cachekit -E all</code></p> </li> </ul>"},{"location":"installation/#development-testing","title":"\ud83d\udee0\ufe0f Development &amp; Testing","text":"<p>For development (with test and dev dependencies):</p> <ul> <li>uv <pre><code>uv sync --all-group\n</code></pre></li> <li>poetry <pre><code>poetry install --with dev\n</code></pre></li> </ul>"},{"location":"installation/#notes","title":"\u26a1\ufe0f Notes","text":"<ul> <li>You only need to install the backend(s) you plan to use.</li> <li>All backends support both sync and async APIs.</li> </ul> <p>Next: Usage Guide \u2192</p>"},{"location":"usage/","title":"\ud83e\uddd1\u200d\ud83d\udcbb Usage Guide","text":"<p>FastAPI Cachekit makes it easy to cache results in your FastAPI app using decorators or dependency injection. Below are the most common usage patterns.</p>"},{"location":"usage/#1-decorator-for-functions","title":"1\ufe0f\u20e3 Decorator for Functions","text":"<p>You can use the <code>@cache.cached()</code> decorator to cache the result of any function (sync or async), not just FastAPI routes.</p> <pre><code>from fast_cache import FastAPICache, InMemoryBackend\n\ncache = FastAPICache()\nbackend = InMemoryBackend()\ncache.init_app(app, backend)\n\n@cache.cached(expire=60)\ndef expensive_computation(x: int):\n    # This result will be cached for 60 seconds\n    return x * 2\n\nresult = expensive_computation(10)  # Cached!\n</code></pre> <ul> <li>Works for both sync and async functions.</li> <li>You can specify <code>expire</code> (in seconds or as a <code>timedelta</code>).</li> </ul>"},{"location":"usage/#2-decorator-for-fastapi-routes","title":"2\ufe0f\u20e3 Decorator for FastAPI Routes","text":"<p>You can use the same decorator directly on your FastAPI endpoints to cache their responses.</p> <pre><code>from fastapi import FastAPI\nfrom fast_cache import FastAPICache, InMemoryBackend\n\napp = FastAPI()\ncache = FastAPICache()\nbackend = InMemoryBackend()\ncache.init_app(app, backend)\n\n@app.get(\"/expensive\")\n@cache.cached(expire=120)\nasync def expensive_route(x: int):\n    # This endpoint's response will be cached for 2 minutes\n    return {\"result\": x * 2}\n</code></pre> <ul> <li>Works for both <code>@app.get</code>, <code>@app.post</code>, etc.</li> <li>Supports both sync and async endpoints.</li> </ul>"},{"location":"usage/#3-dependency-injection-for-advanced-use","title":"3\ufe0f\u20e3 Dependency Injection for Advanced Use","text":"<p>For more control, you can inject the backend and use its methods directly (e.g., for custom cache keys, manual cache control, or advanced logic).</p> <pre><code>from fastapi import Depends\nfrom fast_cache import cache, CacheBackend\n\n## Add The cache init Here\n\n@app.get(\"/profile/{user_id}\")\nasync def get_profile(\n    user_id: int,\n    cache_backend: CacheBackend = Depends(cache.get_cache)\n):\n    key = f\"profile:{user_id}\"\n    cached = await cache_backend.aget(key)\n    if cached:\n        return {\"profile\": cached, \"cached\": True}\n    # Simulate expensive fetch\n    profile = {\"user_id\": user_id, \"bio\": f\"User {user_id} bio\"}\n    await cache_backend.aset(key, profile, expire=60)\n    return {\"profile\": profile, \"cached\": False}\n</code></pre> <ul> <li>Use <code>Depends(cache.get_cache)</code> to inject the backend.</li> <li>Use <code>aget</code>, <code>aset</code>, <code>adelete</code>, etc. for async; <code>get</code>, <code>set</code>, etc. for sync.</li> </ul>"},{"location":"usage/#next-steps","title":"\ud83d\udd17 Next Steps","text":"<ul> <li>API Reference</li> <li>Backends</li> </ul> <p>FastAPI Cachekit makes caching easy, flexible, and production-ready!</p>"},{"location":"backends/dynamodb/","title":"DynamoDB Backend","text":""},{"location":"backends/dynamodb/#installation","title":"Installation","text":"<pre><code>pip install fastapi-cachekit[dynamodb]\n</code></pre>"},{"location":"backends/dynamodb/#setup-with-fastapi","title":"Setup with FastAPI","text":"<pre><code>from fast_cache import FastAPICache\nfrom fast_cache.dynamodb import DynamoDBBackend\n\ncache = FastAPICache()\nbackend = DynamoDBBackend(\n    table_name=\"my_cache_table\",\n    region_name=\"us-east-1\",\n    namespace=\"my-namespace\",  # Optional, default: \"cache\"\n    aws_access_key_id=\"YOUR_AWS_ACCESS_KEY_ID\",         # Optional for local\n    aws_secret_access_key=\"YOUR_AWS_SECRET_ACCESS_KEY\", # Optional for local\n    endpoint_url=\"http://localhost:8000\",               # For DynamoDB Local\n    create_table=True,                                  # Auto-create table if needed\n)\ncache.init_app(app, backend)\n</code></pre>"},{"location":"backends/dynamodb/#options","title":"Options","text":"<ul> <li><code>table_name</code>: Name of the DynamoDB table to use for caching (required)</li> <li><code>region_name</code>: AWS region (e.g., <code>\"us-east-1\"</code>)</li> <li><code>namespace</code>: Key prefix for all cache entries (default: <code>\"cache\"</code>)</li> <li><code>aws_access_key_id</code>: AWS access key (optional for local)</li> <li><code>aws_secret_access_key</code>: AWS secret key (optional for local)</li> <li><code>endpoint_url</code>: Custom endpoint (use <code>\"http://localhost:8000\"</code> for DynamoDB Local)</li> <li><code>create_table</code>: If <code>True</code>, creates the table if it does not exist (default: <code>True</code>)</li> </ul>"},{"location":"backends/dynamodb/#example-usage","title":"Example Usage","text":"<p>You can use the DynamoDB cache backend in three main ways:</p>"},{"location":"backends/dynamodb/#1-function-caching-via-decorator","title":"1. Function Caching via Decorator","text":"<p>Cache the result of any function or endpoint using the <code>@cache.cached</code> decorator. This works for both async and sync functions.</p> <pre><code>from fastapi import FastAPI\nfrom fast_cache import cache, DynamoDBBackend\n\napp = FastAPI()\nbackend = DynamoDBBackend(\n    table_name=\"my_cache_table\",\n    region_name=\"us-east-1\",\n    endpoint_url=\"http://localhost:8000\",\n    aws_access_key_id=\"fake\",\n    aws_secret_access_key=\"fake\",\n    create_table=True,\n)\ncache.init_app(app, backend)\n\n@app.get(\"/expensive\")\n@cache.cached(expire=60)\nasync def expensive_operation(x: int):\n    # This result will be cached for 60 seconds\n    return {\"result\": x * 2}\n</code></pre> <p>You can also use custom cache keys and namespaces:</p> <pre><code>@app.get(\"/custom\")\n@cache.cached(\n    expire=120,\n    key_builder=lambda x: f\"custom:{x}\",\n    namespace=\"special\"\n)\nasync def custom_cache(x: int):\n    return {\"value\": x}\n</code></pre> <p>To skip cache for a specific call, pass <code>skip_cache=True</code> as a query parameter or function argument.</p>"},{"location":"backends/dynamodb/#2-direct-backend-access","title":"2. Direct Backend Access","text":"<p>You can use the backend instance directly for advanced cache operations:</p> <pre><code># Set a value\nawait backend.aset(\"mykey\", {\"foo\": \"bar\"}, expire=30)\n\n# Get a value\nvalue = await backend.aget(\"mykey\")\n\n# Check if a key exists\nexists = await backend.ahas(\"mykey\")\n\n# Delete a key\nawait backend.adelete(\"mykey\")\n\n# Clear all cache in the namespace\nawait backend.aclear()\n</code></pre>"},{"location":"backends/dynamodb/#3-dependency-injection-in-fastapi-endpoints","title":"3. Dependency Injection in FastAPI Endpoints","text":"<p>You can inject the cache backend into your endpoints using FastAPI's dependency system:</p> <pre><code>from fastapi import Depends\nfrom typing import Annotated\n\n@app.get(\"/di/set\")\nasync def set_cache(\n    cache_backend: Annotated[DynamoDBBackend, Depends(cache.get_cache)],\n    key: str,\n    value: str,\n):\n    await cache_backend.aset(key, value, expire=60)\n    return {\"set\": True}\n\n@app.get(\"/di/get\")\nasync def get_cache(\n    cache_backend: Annotated[DynamoDBBackend, Depends(cache.get_cache)],\n    key: str,\n):\n    value = await cache_backend.aget(key)\n    return {\"value\": value}\n</code></pre>"},{"location":"backends/dynamodb/#note","title":"Note","text":"<ul> <li>Use the decorator for simple, automatic caching of endpoint results.</li> <li>Use direct backend access for custom or batch cache operations.</li> <li>Use dependency injection for full control and testability in your endpoints.</li> <li>You can always pass <code>skip_cache=True</code> (For Decorator based) to bypass the cache for a specific call. </li> </ul>"},{"location":"backends/dynamodb/#tips","title":"Tips","text":"<ul> <li>Use DynamoDB for serverless, persistent, and scalable caching on AWS.</li> <li>For local development and testing, use DynamoDB Local and set <code>endpoint_url</code> to <code>\"http://localhost:8000\"</code>.</li> <li>The backend will automatically create the table and enable TTL if <code>create_table=True</code>.</li> <li>Make sure your AWS credentials and permissions are set up if connecting to AWS.</li> <li>Use a unique <code>namespace</code> to avoid key collisions if sharing the table with other apps.</li> </ul>"},{"location":"backends/dynamodb/#example-local-dynamodb-setup","title":"Example: Local DynamoDB Setup","text":"<p>Start DynamoDB Local with Docker:</p> <pre><code>docker run -p 8000:8000 amazon/dynamodb-local\n</code></pre> <p>Then use:</p> <pre><code>backend = DynamoDBBackend(\n    table_name=\"my_cache_table\",\n    region_name=\"us-east-1\",\n    endpoint_url=\"http://localhost:8000\",\n    aws_access_key_id=\"fake\",         # Use dummy values for local\n    aws_secret_access_key=\"fake\",     # Use dummy values for local\n    create_table=True,\n)\n</code></pre>"},{"location":"backends/firestore/","title":"Firestore Backend","text":""},{"location":"backends/firestore/#installation","title":"Installation","text":"<pre><code>pip install fastapi-cachekit[firestore]\n</code></pre>"},{"location":"backends/firestore/#setup-with-fastapi","title":"Setup with FastAPI","text":"<pre><code>from fast_cache import cache, FirestoreBackend\n\nbackend = FirestoreBackend(\n    credential_path=\"path/to/your/service-account.json\",  # Optional if using GOOGLE_APPLICATION_CREDENTIALS\n    namespace=\"my-namespace\",                             # Optional\n    collection_name=\"cache_entries\"                       # Optional\n)\ncache.init_app(app, backend)\n</code></pre>"},{"location":"backends/firestore/#options","title":"Options","text":"<ul> <li><code>credential_path</code>: Path to your Google Cloud service account JSON file.   If not provided, uses the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable.</li> <li><code>namespace</code>: Key prefix for all cache entries (default: <code>\"fastapi_cache\"</code>).</li> <li><code>collection_name</code>: Firestore collection to use for cache entries (default: <code>\"cache_entries\"</code>).</li> </ul>"},{"location":"backends/firestore/#example-usage","title":"Example Usage","text":"<pre><code>@app.get(\"/expensive\")\n@cache.cached(expire=60)\nasync def expensive_operation(x: int):\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"backends/firestore/#tips","title":"Tips","text":"<ul> <li>Use Firestore for serverless, scalable caching with Google Cloud.</li> <li>For local development or CI, you can use the Firestore Emulator.</li> <li>Make sure your service account has Firestore access, or set the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable.</li> <li>The backend supports both sync and async operations.</li> </ul>"},{"location":"backends/in_memory/","title":"In-Memory Backend","text":"<p>The InMemoryBackend is the simplest backend for FastAPI Cachekit. It stores all cached data in the application's memory, making it ideal for local development, testing, or small-scale deployments.</p>"},{"location":"backends/in_memory/#installation","title":"\ud83d\ude80 Installation","text":"<p>No extra dependencies are required! The in-memory backend is built-in and works out of the box.</p> <pre><code>pip install fastapi-cachekit\n</code></pre>"},{"location":"backends/in_memory/#setup-with-fastapi","title":"\u2699\ufe0f Setup with FastAPI","text":"<pre><code>from fast_cache import FastAPICache, InMemoryBackend\n\ncache = FastAPICache()\nbackend = InMemoryBackend(namespace=\"myapp-cache\")\ncache.init_app(app, backend)\n</code></pre> <ul> <li><code>namespace</code> (optional): Prefix for all cache keys (default: <code>\"fastapi-cache\"</code>).</li> </ul>"},{"location":"backends/in_memory/#example-usage","title":"\ud83e\uddd1\u200d\ud83d\udcbb Example Usage","text":"<pre><code>@app.get(\"/expensive\")\n@cache.cached(expire=60)\nasync def expensive_operation(x: int):\n    # This result will be cached in memory for 60 seconds\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"backends/in_memory/#options","title":"\ud83d\udcdd Options","text":"<ul> <li> <p>namespace:   A string prefix for all cache keys. Useful if you run multiple apps in the same process.</p> </li> <li> <p>max_size (optional):   Maximum number of items to store in the cache.   If set, the cache will evict the least recently used (LRU) items when full.</p> </li> </ul> <pre><code>backend = InMemoryBackend(namespace=\"myapp-cache\", max_size=1000)\n</code></pre>"},{"location":"backends/in_memory/#limitations","title":"\u26a0\ufe0f Limitations","text":"<ul> <li>Not shared between processes or servers:   Each process has its own cache. Not suitable for distributed or multi-worker deployments.</li> <li>Data is lost on restart:   The cache is cleared when the app restarts.</li> <li>Best for development, testing, or single-process apps.</li> </ul>"},{"location":"backends/in_memory/#see-also","title":"\ud83d\udd17 See Also","text":"<ul> <li>Backends Overview</li> <li>API Reference</li> <li>Usage Guide</li> </ul>"},{"location":"backends/memcached/","title":"Memcached Backend","text":"<p>The MemcachedBackend allows you to use a Memcached server as a cache store for FastAPI Cachekit. This backend is ideal for high-speed, distributed caching in stateless applications.</p>"},{"location":"backends/memcached/#installation","title":"\ud83d\ude80 Installation","text":"<p>Install FastAPI Cachekit with Memcached support:</p> <pre><code>pip install fastapi-cachekit[memcached]\n</code></pre> <p>Or with other tools:</p> <ul> <li>uv <pre><code>uv add fastapi-cachekit[memcached]\n</code></pre></li> <li>poetry <pre><code>poetry add fastapi-cachekit -E memcached\n</code></pre></li> </ul>"},{"location":"backends/memcached/#setup-with-fastapi","title":"\u2699\ufe0f Setup with FastAPI","text":"<pre><code>from fast_cache import cache, MemcachedBackend\n\nbackend = MemcachedBackend(\n    host=\"localhost\",\n    port=11211,\n    namespace=\"myapp-cache\"\n)\ncache.init_app(app, backend)\n</code></pre> <ul> <li><code>host</code>: Memcached server host (default: <code>\"localhost\"</code>)</li> <li><code>port</code>: Memcached server port (default: <code>11211</code>)</li> <li><code>namespace</code>: Prefix for all cache keys (default: <code>\"fastapi-cache\"</code>)</li> </ul>"},{"location":"backends/memcached/#example-usage","title":"\ud83e\uddd1\u200d\ud83d\udcbb Example Usage","text":"<pre><code>@app.get(\"/expensive\")\n@cache.cached(expire=60)\nasync def expensive_operation(x: int):\n    # This result will be cached in Memcached for 60 seconds\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"backends/memcached/#options","title":"\ud83d\udcdd Options","text":"<ul> <li> <p>host:   Memcached server host (default: <code>\"localhost\"</code>)</p> </li> <li> <p>port:   Memcached server port (default: <code>11211</code>)</p> </li> <li> <p>namespace:   String prefix for all cache keys (default: <code>\"fastapi-cache\"</code>)</p> </li> <li> <p>pool_size:   Maximum number of connections in the sync pool (default: <code>2</code>)</p> </li> </ul>"},{"location":"backends/memcached/#notes","title":"\u26a1\ufe0f Notes","text":"<ul> <li>Memcached is a high-speed, in-memory, distributed cache.</li> <li>No persistence: Data is lost if the server restarts.</li> <li>No built-in authentication by default:   SASL authentication is available if enabled on the server and configured in the backend.</li> <li>Best for stateless, high-throughput caching.</li> </ul>"},{"location":"backends/memcached/#example-using-sasl-authentication","title":"\ud83d\udee0\ufe0f Example: Using SASL Authentication","text":"<p>If your Memcached server is configured with SASL:</p> <pre><code>backend = MemcachedBackend(\n    host=\"localhost\",\n    port=11211,\n    username=\"myuser\",\n    password=\"mypassword\"\n)\n</code></pre>"},{"location":"backends/memcached/#see-also","title":"\ud83d\udd17 See Also","text":"<ul> <li>Backends Overview</li> <li>API Reference</li> <li>Usage Guide</li> </ul>"},{"location":"backends/mongodb/","title":"MongoDB Backend","text":"<p>The MongoDBBackend allows you to use a MongoDB database as a cache store for FastAPI Cachekit. This backend is ideal when you want persistent, document-based caching, or when you already have a MongoDB database in your stack. It supports automatic cache expiration using MongoDB\u2019s TTL (Time-To-Live) indexes, making it easy to manage cache lifetimes efficiently.</p>"},{"location":"backends/mongodb/#installation","title":"\ud83d\ude80 Installation","text":"<p>Install FastAPI Cachekit with MongoDB support:</p> <pre><code>pip install fastapi-cachekit[mongodb]\n</code></pre> <p>Or with other tools:</p> <ul> <li>uv <pre><code>uv add fastapi-cachekit[mongodb]\n</code></pre></li> <li>poetry <pre><code>poetry add fastapi-cachekit -E mongodb\n</code></pre></li> </ul>"},{"location":"backends/mongodb/#setup-with-fastapi","title":"\u2699\ufe0f Setup with FastAPI","text":"<pre><code>from fast_cache import cache, MongoDBBackend\n\nbackend = MongoDBBackend(\n    uri=\"mongodb://user:password@localhost:27017/mydb\",\n    namespace=\"myapp_cache\"\n)\ncache.init_app(app, backend)\n</code></pre> <ul> <li><code>uri</code>: MongoDB connection string With All necessary Auth and Db in URL (required)</li> <li><code>namespace</code>: Prefix for all cache keys (default: <code>\"fastapi_cache\"</code>)</li> </ul>"},{"location":"backends/mongodb/#example-usage","title":"\ud83e\uddd1\u200d\ud83d\udcbb Example Usage","text":"<pre><code>@app.get(\"/expensive\")\n@cache.cached(expire=120)\nasync def expensive_operation(x: int):\n    # This result will be cached in Postgres for 2 minutes\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"backends/mongodb/#about-mongodb-ttl-cache","title":"\u26a1\ufe0f About MongoDB TTL Cache","text":"<p>This backend uses a MongoDB collection with a TTL (Time-To-Live) index for storing cache entries.</p> <ul> <li>TTL Indexes in MongoDB automatically remove expired cache entries, so you don\u2019t need to manage expiration manually.</li> <li>Benefit: Cache data is persistent across app and database restarts, and expired data is cleaned up automatically by MongoDB\u2019s background process.</li> <li>Drawback: Expired documents may not be deleted immediately (MongoDB\u2019s TTL monitor runs every 60 seconds by default), so there may be a short delay before expired cache entries are removed.</li> </ul> <p>In summary: - Cache data is persistent and automatically expired, but there may be a short delay before expired entries are deleted. - If you need instant removal of expired data, you should check expiration in your code (this backend does so).</p>"},{"location":"backends/mongodb/#tips-limitations","title":"\u26a0\ufe0f Tips &amp; Limitations","text":"<ul> <li>Requires a running MongoDB server.</li> <li>Data is persistent across app and database restarts.</li> <li>Slightly slower than in-memory or Redis for high-throughput caching, but great for persistence and document-based setups.</li> <li>Best for apps already using MongoDB or needing persistent, auto-expiring cache.</li> <li>TTL index expiration is not instantaneous; expired documents are removed in the background.</li> </ul>"},{"location":"backends/mongodb/#how-it-works","title":"\ud83d\udcdd How It Works","text":"<ul> <li>Each cache entry is stored as a document with:</li> <li><code>_id</code>: the cache key (optionally namespaced)</li> <li><code>value</code>: the pickled cached value</li> <li><code>expires_at</code>: epoch time when the entry should expire</li> <li>A TTL index is created on the <code>expires_at</code> field.</li> <li>Expired documents are deleted automatically by MongoDB\u2019s TTL monitor.</li> <li>Expiration is also checked in code to avoid returning stale data.</li> </ul>"},{"location":"backends/mongodb/#when-to-use","title":"\ud83d\udea6 When to Use","text":"<ul> <li>You want persistent, document-based caching.</li> <li>You already have a MongoDB database in your stack.</li> <li>You want automatic cache expiration without manual cleanup.</li> </ul>"},{"location":"backends/mongodb/#see-also","title":"\ud83d\udd17 See Also","text":"<ul> <li>Backends Overview</li> <li>API Reference</li> <li>Usage Guide</li> </ul>"},{"location":"backends/postgres/","title":"Postgres Backend","text":"<p>The PostgresBackend allows you to use a PostgreSQL database as a cache store for FastAPI Cachekit. This backend is ideal when you want persistent, SQL-based caching, or when you already have a PostgreSQL database in your stack.</p>"},{"location":"backends/postgres/#installation","title":"\ud83d\ude80 Installation","text":"<p>Install FastAPI Cachekit with Postgres support:</p> <pre><code>pip install fastapi-cachekit[postgres]\n</code></pre> <p>Or with other tools:</p> <ul> <li>uv <pre><code>uv add fastapi-cachekit[postgres]\n</code></pre></li> <li>poetry <pre><code>poetry add fastapi-cachekit -E postgres\n</code></pre></li> </ul>"},{"location":"backends/postgres/#setup-with-fastapi","title":"\u2699\ufe0f Setup with FastAPI","text":"<pre><code>from fast_cache import cache, PostgresBackend\n\nbackend = PostgresBackend(\n    dsn=\"postgresql://user:password@localhost:5432/mydb\",\n    namespace=\"myapp_cache\"\n)\ncache.init_app(app, backend)\n</code></pre> <ul> <li><code>dsn</code>: PostgreSQL connection string (required)</li> <li><code>namespace</code>: Prefix for all cache keys (default: <code>\"fastapi_cache\"</code>)</li> </ul>"},{"location":"backends/postgres/#example-usage","title":"\ud83e\uddd1\u200d\ud83d\udcbb Example Usage","text":"<pre><code>@app.get(\"/expensive\")\n@cache.cached(expire=120)\nasync def expensive_operation(x: int):\n    # This result will be cached in Postgres for 2 minutes\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"backends/postgres/#options","title":"\ud83d\udcdd Options","text":"<ul> <li>dsn:   PostgreSQL connection string, e.g. <code>postgresql://user:password@localhost:5432/mydb</code></li> <li>namespace:   String prefix for all cache keys (default: <code>\"fastapi-cache\"</code>)</li> <li>min_size:   Minimum number of connections in the pool (default: 1)</li> <li>max_size:   Maximum number of connections in the pool (default: 10)</li> </ul> <pre><code>backend = PostgresBackend(\n    dsn=\"postgresql://user:password@localhost:5432/mydb\",\n    namespace=\"myapp-cache\",\n    min_size=2,\n    max_size=20\n)\n</code></pre>"},{"location":"backends/postgres/#about-unlogged-tables","title":"\u26a1\ufe0f About UNLOGGED TABLES","text":"<p>This backend uses a PostgreSQL UNLOGGED TABLE for storing cache entries.</p> <ul> <li>UNLOGGED TABLES are much faster than regular tables because they do not write to the PostgreSQL write-ahead log (WAL).</li> <li>Drawback: Data in an unlogged table is not crash-safe\u2014if the database server crashes, all cached data in the table is lost.</li> <li>Benefit: For cache data, this is usually acceptable and gives a significant performance boost.</li> </ul> <p>In summary: - Cache data is fast and persistent across app restarts, but not across database crashes. - If you need crash-safe persistence, consider using a regular table (open an issue or PR for support).</p>"},{"location":"backends/postgres/#tips-limitations","title":"\u26a0\ufe0f Tips &amp; Limitations","text":"<ul> <li>Requires a running PostgreSQL server.</li> <li>Data is persistent across app restarts, but not across database crashes (due to UNLOGGED TABLE).</li> <li>Slightly slower than in-memory or Redis for high-throughput caching, but great for persistence and SQL-based setups.</li> <li>Best for apps already using PostgreSQL or needing persistent cache.</li> </ul>"},{"location":"backends/postgres/#see-also","title":"\ud83d\udd17 See Also","text":"<ul> <li>Backends Overview</li> <li>API Reference</li> <li>Usage Guide</li> </ul>"},{"location":"backends/redis/","title":"Redis Backend","text":""},{"location":"backends/redis/#installation","title":"Installation","text":"<pre><code>pip install fastapi-cachekit[redis]\n</code></pre>"},{"location":"backends/redis/#setup-with-fastapi","title":"Setup with FastAPI","text":"<pre><code>from fast_cache import FastAPICache, RedisBackend\n\ncache = FastAPICache()\nbackend = RedisBackend(redis_url=\"redis://localhost:6379/0\")\ncache.init_app(app, backend)\n</code></pre>"},{"location":"backends/redis/#options","title":"Options","text":"<ul> <li><code>redis_url</code>: Redis connection string</li> <li><code>namespace</code>: Key prefix for all cache entries</li> </ul>"},{"location":"backends/redis/#example-usage","title":"Example Usage","text":"<pre><code>@app.get(\"/expensive\")\n@cache.cached(expire=60)\nasync def expensive_operation(x: int):\n    return {\"result\": x * 2}\n</code></pre>"},{"location":"backends/redis/#tips","title":"Tips","text":"<ul> <li>Use Redis for distributed, production-grade caching.</li> <li>Make sure your Redis server is running and accessible.</li> </ul>"}]}